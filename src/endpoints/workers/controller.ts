/* eslint-disable no-unused-vars */

// import { Types } from '../../vs-core';

import {
  getDistanceFromLatLonInKm,
  getSourceEntityData,
  nameof,
  processSchemaFieldItem,
  toDateObject,
} from '../../helpers/coreHelper';
import {
  CMSCollections,
  DailyReportStatusTypes,
  IDailyReport,
  IPatientsSchedule,
  IPatientsSchedulesException,
  IUsersAddress,
  IWorker,
  PatientsSchedulesExceptionTypes,
} from '../../types/@autogenerated';

import { ErrorHelper } from '../../vs-core-firebase';
import { fetchSingleItem, listByPropInner } from '../../vs-core-firebase/helpers/firestoreHelper';
import { BusinessError, TechnicalError } from '../../vs-core/error';
import { StateTypes } from '../../vs-core/types';
import { createEntity, fetchSchemaWithFields } from '../cms/helpers';

import * as admin from 'firebase-admin';
import { ENVIRONMENT } from '../../config/appConfig';
import {
  IAppointment,
  AppointmentStatusTypes,
  ScheduleItineraryTypes,
} from '../../types/appointments';

const fetchWorkerByUserId = async ({
  organizationId,
  userId,
}: {
  organizationId: string;
  userId: string;
}): Promise<IWorker | null> => {
  console.log('fetching worker by id ' + userId);

  const workerData = (await fetchSingleItem({
    collectionName: `${organizationId}_${CMSCollections.WORKERS}`,
    id: userId,
  })) as IWorker;

  if (!workerData) return null;

  const applicantQuotationEntitySchemaWithFields = await fetchSchemaWithFields(
    null,
    organizationId,
    CMSCollections.WORKERS
  );

  processSchemaFieldItem(workerData, applicantQuotationEntitySchemaWithFields.fields);

  return workerData;
};

const fetchItinerary = async ({
  organizationId,
  itineraryId,
  itineraryType,
}: {
  organizationId: string;
  itineraryId: string;
  itineraryType: ScheduleItineraryTypes;
}): Promise<IPatientsSchedule | null> => {
  console.log('fetching itinerary');

  const db = admin.firestore();

  let itineraryRef = null;

  if (itineraryType === ScheduleItineraryTypes.RECURRENT) {
    itineraryRef = db
      .collection(`${organizationId}_${CMSCollections.PATIENTS_SCHEDULES}`)
      .where('state', '==', StateTypes.STATE_ACTIVE)
      .where(nameof<IPatientsSchedule>('id'), '==', itineraryId);
    // .where(nameof<IPatientWorker>('patientId'), '==', patientId);
  } else {
    itineraryRef = db
      .collection(`${organizationId}_${CMSCollections.PATIENTS_SCHEDULES}`)
      .where('state', '==', StateTypes.STATE_ACTIVE)
      .where(nameof<IPatientsSchedule>('id'), '==', itineraryId);
    // .where(nameof<IPatientWorker>('patientId'), '==', patientId);
  }

  const itineraryQuerySnapshot = await itineraryRef.get();

  if (!itineraryQuerySnapshot.docs || !itineraryQuerySnapshot.docs.length) {
    return null;
  }

  const itineraryData = itineraryQuerySnapshot.docs[0].data() as IPatientsSchedule;

  const patientSchedulesEntitySchemaWithFields = await fetchSchemaWithFields(
    null,
    organizationId,
    CMSCollections.PATIENTS_SCHEDULES
  );

  processSchemaFieldItem(itineraryData, patientSchedulesEntitySchemaWithFields.fields);

  // const itinerary = { workerId: worker.id, patientId, address: { latitude, longitude } };

  return itineraryData;
};

const fetchUserAddress = async ({
  organizationId,
  userAddressId,
}: {
  organizationId: string;
  userAddressId: string;
}): Promise<IUsersAddress | null> => {
  console.log('fetching user address');

  const db = admin.firestore();

  const itineraryRef = db
    .collection(`${organizationId}_${CMSCollections.USERS_ADDRESSES}`)
    .doc(userAddressId);

  const itineraryQuerySnapshot = await itineraryRef.get();

  if (!itineraryQuerySnapshot.exists) {
    return null;
  }

  const itineraryData = itineraryQuerySnapshot.data() as IUsersAddress;

  const userAddressesEntitySchemaWithFields = await fetchSchemaWithFields(
    null,
    organizationId,
    CMSCollections.USERS_ADDRESSES
  );

  processSchemaFieldItem(itineraryData, userAddressesEntitySchemaWithFields.fields);

  return itineraryData;
};

const getRelatedDailyReport = (
  dailyReports: IDailyReport[],
  itineraryId: string,
  currentDay: Date,
  startHours: Date
) => {
  return dailyReports.find((dailyReport) => {
    // defino que hay match si:
    if (dailyReport.patientScheduleId !== itineraryId) return false;

    // y es mismo dia que el day
    const dailyReportStartDate = new Date(
      Date.UTC(
        dailyReport.checkIn.getUTCFullYear(),
        dailyReport.checkIn.getUTCMonth(),
        dailyReport.checkIn.getUTCDate()
      )
    );
    const currentDayStartDate = new Date(
      Date.UTC(currentDay.getUTCFullYear(), currentDay.getUTCMonth(), currentDay.getUTCDate())
    );

    if (dailyReportStartDate.getTime() !== currentDayStartDate.getTime()) return false;
    // y mismo horario de inicio
    // si esta cancelado es pq es el mismo id de itinerario y tmb la hora de inicio es igual
    const scheduleStartDatetime = new Date(
      2000,
      1,
      1,
      startHours.getUTCHours(),
      startHours.getUTCMinutes()
    );
    const dailyReportStartDatetime = new Date(
      2000,
      1,
      1,
      dailyReport.checkIn.getUTCHours(),
      dailyReport.checkIn.getUTCMinutes()
    );

    const diff = scheduleStartDatetime.getTime() - dailyReportStartDatetime.getTime();

    const diffInMinutes = Math.round(diff / 60000);

    const JOB_CHECK_IN_OUT_TOLERANCE_IN_MINUTES = 60;

    if (diffInMinutes >= JOB_CHECK_IN_OUT_TOLERANCE_IN_MINUTES) return false;

    return true;
  });
};
const validateAllowCheckInOrOut = async ({
  userId,
  organizationId,
  patientId,
  itineraryId,
  itineraryType,
  latitude,
  longitude,
  actionType,
}: {
  userId: string;
  organizationId: string;
  patientId: string;
  itineraryId: string;
  itineraryType: ScheduleItineraryTypes;
  latitude: number;
  longitude: number;
  actionType: 'in' | 'out';
}): Promise<void> => {
  if (!patientId || !itineraryId || !itineraryType) {
    throw new TechnicalError('ERROR_MISSING_ARGS', null, 'missing args', null);
  }

  // 1. Obtengo worker relacionado al userId
  const worker = await fetchWorkerByUserId({ organizationId, userId });

  if (!worker) throw new Error('Missing worker (' + userId + ')');

  // 2. obtengo el itinerario
  const itinerary = await fetchItinerary({ organizationId, itineraryId, itineraryType });

  if (itinerary.workerId !== userId || patientId !== itinerary.userId) {
    throw new Error(
      'Invalid Itinerary, not related to received data ' +
        JSON.stringify(itinerary) +
        ' !== ' +
        JSON.stringify({ itineraryId, itineraryType, userId, patientId })
    );
  }

  // 3. del itinerario me fijo la direcciÃ³n y valido contra la lat y lng
  const DISTANCE_TOLERANCE_IN_KM = 10;

  const userAddress = await fetchUserAddress({
    organizationId,
    userAddressId: itinerary.userAddressId,
  });

  const distanceFromJobAddress = getDistanceFromLatLonInKm(
    longitude,
    latitude,
    userAddress.address.lng,
    userAddress.address.lat
  );

  console.log('ValidateAllowCheckInOrOut', {
    longitude,
    latitude,
    addresslng: userAddress.address.lng,
    addressLat: userAddress.address.lat,
    distanceFromJobAddress,
  });

  if (distanceFromJobAddress > DISTANCE_TOLERANCE_IN_KM) {
    if (ENVIRONMENT === 'qa' || ENVIRONMENT === 'local') {
      console.warn('Must be closer to address, bypass because of environment not production');
    } else {
      throw new BusinessError(
        'JOB_INVALID_LOCATION',
        null,
        'Must be closer to address (' +
          Math.round(distanceFromJobAddress) +
          ' km > ' +
          DISTANCE_TOLERANCE_IN_KM +
          ' km)'
      );
    }
  }

  // 4. obtengo los daily reports de este worker
  // TODO filtrarlos por check in / out y fecha para acotar busqueda
  const workerDailyReportsResponse = (await listByPropInner({
    limit: 1000,
    offset: 0,
    filters: null,

    primaryEntityPropName: nameof<IDailyReport>('workerId'),
    primaryEntityValue: worker.id,

    listByCollectionName: organizationId + '_' + CMSCollections.DAILY_REPORTS,
    indexedFilters: [nameof<IDailyReport>('workerId')],
    postProcessor: null,
    overridePrimaryRelationshipOperator: null,
    relationships: null,
  })) as { items: IDailyReport[] };

  const relatedDailyReport = getRelatedDailyReport(
    workerDailyReportsResponse.items,
    itinerary.id,
    new Date(Date.now()),
    itinerary.startHour
  );

  // 5. get existent check in for this itinerary
  if (actionType === 'in') {
    // validate no duplicity
    if (relatedDailyReport) {
      throw new Error('Duplicated check in');
    }
  } else {
    // check-out
    // validate check in existance
    if (!relatedDailyReport) {
      throw new Error('Missing check in');
    }
  }
};

const addDays = (date: Date, days: number) => {
  date.setDate(date.getDate() + days);
  return date;
};

const getDaysBetween: (from: Date, to: Date) => Date[] = (from: Date, to: Date) => {
  const daysBetween = [];
  let currentDate = from;
  while (currentDate <= to) {
    daysBetween.push(new Date(currentDate));
    currentDate = addDays(currentDate, 1);
  }

  return daysBetween;
};

exports.workerSchedule = async function (req, res) {
  try {
    // userId = workerId
    const { userId, organizationId } = res.locals;
    if (!req.query) throw new Error('missing from / to query string params (1)');

    // from / to = Appointments desde hasta para esta consulta
    const { from, to } = req.query;

    if (!from || !to) throw new Error('missing from / to query string params (2)');

    // 1. Obtengo worker relacionado al userId recibido
    const worker = await fetchWorkerByUserId({ organizationId, userId });

    if (!worker) throw new Error('Missing worker (' + userId + ')');

    const fromDate = toDateObject(from);
    const toDate = toDateObject(to);

    if (!fromDate || !toDate) throw new Error('invalid from / to query string params');

    // 2. obtengo itinerario recurrente (patientSchedules)
    const recurrentWorkerSchedulesResponse = (await listByPropInner({
      limit: 1000,
      offset: 0,
      filters: null,

      primaryEntityPropName: nameof<IPatientsSchedule>('workerId'),
      primaryEntityValue: worker.id,

      listByCollectionName: organizationId + '_' + CMSCollections.PATIENTS_SCHEDULES,
      indexedFilters: [nameof<IPatientsSchedule>('workerId')],
      postProcessor: null,
      overridePrimaryRelationshipOperator: null,
      relationships: [
        {
          collectionName: organizationId + '_' + CMSCollections.PATIENTS,
          propertyName: nameof<IPatientsSchedule>('userId'),
        },
        {
          collectionName: organizationId + '_' + CMSCollections.USERS_ADDRESSES,
          propertyName: nameof<IPatientsSchedule>('userAddressId'),
        },
      ],
    })) as { items: IPatientsSchedule[] };

    // 3. obtengo daily reports de este worker, TODO MICHEL agregar filtro de fechas - 1 + 1 dia respecto fromDate toDate
    const workerDailyReportsResponse = (await listByPropInner({
      limit: 1000,
      offset: 0,
      filters: null,

      primaryEntityPropName: nameof<IDailyReport>('workerId'),
      primaryEntityValue: worker.id,

      listByCollectionName: organizationId + '_' + CMSCollections.DAILY_REPORTS,
      indexedFilters: [nameof<IDailyReport>('workerId')],
      postProcessor: null,
      overridePrimaryRelationshipOperator: null,
      relationships: null,
    })) as { items: IDailyReport[] };

    // 4. obtengo itinerario eventual (excepciones = PATIENTS_SCHEDULES_EXCEPTIONS) filtrando por prop workerId
    const eventualWorkerSchedulesResponse = (await listByPropInner({
      limit: 1000,
      offset: 0,
      filters: null,

      primaryEntityPropName: nameof<IPatientsSchedulesException>('workerId'),
      primaryEntityValue: worker.id,

      listByCollectionName: organizationId + '_' + CMSCollections.PATIENTS_SCHEDULES_EXCEPTIONS,
      indexedFilters: [nameof<IPatientsSchedulesException>('workerId')],
      postProcessor: null,
      overridePrimaryRelationshipOperator: null,
      relationships: [
        {
          collectionName: organizationId + '_' + CMSCollections.USERS_ADDRESSES,
          propertyName: nameof<IPatientsSchedulesException>('userAddressId'),
        },
      ],
    })) as { items: IPatientsSchedulesException[] };

    // me quedo con los cancelados de este worker
    const cancelledWorkerSchedules = eventualWorkerSchedulesResponse.items.filter(
      (eventualSchedule) => {
        return (
          eventualSchedule.patientsSchedulesExceptionType ===
          PatientsSchedulesExceptionTypes.CANCELLED
        );
      }
    );

    const daysBetween = getDaysBetween(fromDate, toDate);

    const workerAppointments: IAppointment[] = [];

    // genera workerAppointments por cada day of week que esten entre la franja fromDate / toDate
    // evalua los daily reports para entender el appointmentstatus (checked in / out / pending / done)
    daysBetween.forEach((day) => {
      const dayOfWeek = day.getDay(); // 0 = sunday, 1 = monday, ...

      // me quedo con todos los itinerarios recurrentes del dia
      const recurrentItineraries = recurrentWorkerSchedulesResponse.items.filter(
        (recurrentItinerary) => {
          return recurrentItinerary.dayOfWeek === dayOfWeek;
        }
      );

      recurrentItineraries.forEach((itinerary) => {
        const relatedPatient = getSourceEntityData({
          obj: itinerary,
          key: nameof<IPatientsSchedule>('userId'),
        });

        if (!relatedPatient) {
          console.error('Missing related patient (' + itinerary.id + ')');
          return;
        }

        const userAddress = getSourceEntityData({
          obj: itinerary,
          key: nameof<IPatientsSchedule>('userAddressId'),
        });

        if (!userAddress) {
          console.error('Missing related user address (' + itinerary.id + ')');
          return;
        }

        // si existe un registro en cancelados entonces lo omito
        const isCancelled = cancelledWorkerSchedules.find((cancelledSchedule) => {
          // defino que hay match si:
          // mismo id de itinerario (Los lunes 12.30 hasta 2.30 o los miercoles 9.00 a 18.00)
          if (cancelledSchedule.relatedPatientScheduleId !== itinerary.id) return false;

          // y es mismo dia que el day
          const cancelledEventStartDate = new Date(
            Date.UTC(
              cancelledSchedule.start.getUTCFullYear(),
              cancelledSchedule.start.getUTCMonth(),
              cancelledSchedule.start.getUTCDate()
            )
          );
          const currentDayStartDate = new Date(
            Date.UTC(day.getUTCFullYear(), day.getUTCMonth(), day.getUTCDate())
          );

          if (cancelledEventStartDate.getTime() !== currentDayStartDate.getTime()) return false;
          // y mismo horario de inicio
          // si esta cancelado es pq es el mismo id de itinerario y tmb la hora de inicio es igual
          const scheduleStartDatetime = new Date(
            2000,
            1,
            1,
            itinerary.startHour.getUTCHours(),
            itinerary.startHour.getUTCMinutes()
          );
          const cancelledStartDatetime = new Date(
            2000,
            1,
            1,
            cancelledSchedule.start.getUTCHours(),
            cancelledSchedule.start.getUTCMinutes()
          );

          if (scheduleStartDatetime.getTime() !== cancelledStartDatetime.getTime()) return false;

          return true;
        });

        const relatedDailyReport = getRelatedDailyReport(
          workerDailyReportsResponse.items,
          itinerary.id,
          day,
          itinerary.startHour
        );

        let appointmentStatus = AppointmentStatusTypes.PENDING;

        if (isCancelled) {
          appointmentStatus = AppointmentStatusTypes.CANCELLED;
        } else if (
          relatedDailyReport &&
          relatedDailyReport.dailyReportStatus === DailyReportStatusTypes.COMPLETED
        ) {
          appointmentStatus = AppointmentStatusTypes.DONE;
        } else if (relatedDailyReport && relatedDailyReport.checkOut) {
          appointmentStatus = AppointmentStatusTypes.CHECKED_OUT;
        } else if (relatedDailyReport && relatedDailyReport.checkIn) {
          appointmentStatus = AppointmentStatusTypes.CHECKED_IN;
        }

        const start = new Date(
          day.getUTCFullYear(),
          day.getUTCMonth(),
          day.getUTCDate(),
          itinerary.startHour.getHours(),
          itinerary.startHour.getMinutes()
        );
        const end = new Date(
          day.getUTCFullYear(),
          day.getUTCMonth(),
          day.getUTCDate(),
          itinerary.endHour.getHours(),
          itinerary.endHour.getMinutes()
        );

        const appointment: IAppointment = {
          start,
          end,
          patient: relatedPatient,
          worker,
          userAddress,
          appointmentStatus,
          itineraryId: itinerary.id,
          itineraryType: ScheduleItineraryTypes.RECURRENT,
        };

        workerAppointments.push(appointment);
      });
    });

    // 5 obtengo itinerario eventual (excepciones = PATIENTS_SCHEDULES_EXCEPTIONS) filtrando por prop reasignedWorkerId y el estado es scheduleExceptionStatus = reasigned
    const eventualReasignedWorkerSchedulesResponse = (await listByPropInner({
      limit: 1000,
      offset: 0,
      filters: null,

      primaryEntityPropName: nameof<IPatientsSchedulesException>('reasignedWorkerId'),
      primaryEntityValue: worker.id,

      listByCollectionName: organizationId + '_' + CMSCollections.PATIENTS_SCHEDULES_EXCEPTIONS,
      indexedFilters: [nameof<IPatientsSchedulesException>('reasignedWorkerId')],
      postProcessor: null,
      overridePrimaryRelationshipOperator: null,
      relationships: [
        {
          collectionName: organizationId + '_' + CMSCollections.PATIENTS,
          propertyName: nameof<IPatientsSchedulesException>('userId'),
        },
        {
          collectionName: organizationId + '_' + CMSCollections.USERS_ADDRESSES,
          propertyName: nameof<IPatientsSchedulesException>('userAddressId'),
        },
      ],
    })) as { items: IPatientsSchedulesException[] };

    // 3.2.1 sumar estos registros al array de workerAppointments
    eventualReasignedWorkerSchedulesResponse.items.forEach((eventualSchedule) => {
      const relatedDailyReport = getRelatedDailyReport(
        workerDailyReportsResponse.items,
        eventualSchedule.relatedPatientScheduleId,
        eventualSchedule.start,
        eventualSchedule.start
      );

      const relatedPatient = getSourceEntityData({
        obj: eventualSchedule,
        key: nameof<IPatientsSchedulesException>('userId'),
      });

      if (!relatedPatient) {
        console.error('Missing related patient (2) (' + eventualSchedule.id + ')');
        return;
      }

      const userAddress = getSourceEntityData({
        obj: eventualSchedule,
        key: nameof<IPatientsSchedulesException>('userAddressId'),
      });

      if (!userAddress) {
        console.error('Missing related user address (2) (' + eventualSchedule.id + ')');
        return;
      }

      let appointmentStatus = AppointmentStatusTypes.PENDING;

      if (relatedDailyReport.dailyReportStatus === DailyReportStatusTypes.COMPLETED) {
        appointmentStatus = AppointmentStatusTypes.DONE;
      } else if (relatedDailyReport.checkOut) {
        appointmentStatus = AppointmentStatusTypes.CHECKED_OUT;
      } else if (relatedDailyReport.checkIn) {
        appointmentStatus = AppointmentStatusTypes.CHECKED_IN;
      }
      const appointment: IAppointment = {
        start: eventualSchedule.start,
        end: eventualSchedule.end,
        patient: relatedPatient,
        worker,
        userAddress,
        appointmentStatus,
        itineraryId: eventualSchedule.relatedPatientScheduleId,
        itineraryType: ScheduleItineraryTypes.EVENTUAL,
      };

      workerAppointments.push(appointment);
    });

    return res.send(workerAppointments);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.getPatientReports = async function (req, res) {
  try {
    const { userId, organizationId } = res.locals;
    const { patientId, itineraryId, itineraryType } = req.params;
    const { latitude, longitude } = req.query;

    await validateAllowCheckInOrOut({
      userId,
      organizationId,
      patientId,
      itineraryId,
      itineraryType,
      latitude,
      longitude,

      actionType: 'out',
    });

    // 1. actualizar daily report

    return res.send([]);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.allowCheckIn = async function (req, res) {
  try {
    const { userId, organizationId } = res.locals;
    const { patientId, itineraryId, itineraryType } = req.params;
    const { latitude, longitude } = req.query;

    try {
      await validateAllowCheckInOrOut({
        userId,
        organizationId,
        patientId,
        itineraryId,
        itineraryType,
        latitude,
        longitude,

        actionType: 'in',
      });
    } catch (e) {
      if (e.name !== 'BusinessError') {
        throw e;
      }

      const businessError = e as BusinessError;
      return res.send({
        allowed: false,
        reasonMessage: businessError.message,
        reasonTitle: businessError.code,
      });
    }

    return res.send({ allowed: true });
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.allowCheckOut = async function (req, res) {
  try {
    const { userId, organizationId } = res.locals;
    const { patientId, itineraryId, itineraryType } = req.params;
    const { latitude, longitude } = req.query;

    try {
      await validateAllowCheckInOrOut({
        userId,
        organizationId,
        patientId,
        itineraryId,
        itineraryType,
        latitude,
        longitude,

        actionType: 'out',
      });
    } catch (e) {
      if (e.name !== 'BusinessError') {
        throw e;
      }

      const businessError = e as BusinessError;
      return res.send({
        allowed: false,
        reasonMessage: businessError.message,
        reasonTitle: businessError.code,
      });
    }

    // validar que haya hecho un check in para este itinerario (busco en los daily reports)

    return res.send({ allowed: true });
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.checkIn = async function (req, res) {
  try {
    const { userId, organizationId } = res.locals;
    const { patientId, itineraryId, itineraryType } = req.params;
    const { latitude, longitude } = req.body;

    await validateAllowCheckInOrOut({
      userId,
      organizationId,
      patientId,
      itineraryId,
      itineraryType,
      latitude,
      longitude,

      actionType: 'in',
    });

    // 1. crear daily report
    console.log('fetching schema by name: ' + CMSCollections.DAILY_REPORTS);

    const dailyReportsEntitySchemaWithFields = await fetchSchemaWithFields(
      null,
      organizationId,
      CMSCollections.DAILY_REPORTS
    );

    const dailyReportBody: IDailyReport = {
      userId: patientId,
      patientScheduleId: itineraryId,
      workerId: userId.id,
      dailyReportStatus: DailyReportStatusTypes.EMPTY,
      checkInLatitude: latitude,
      checkInLongitude: longitude,
      checkIn: new Date(Date.now()),
      eventDate: new Date(Date.now()),
      // globalScore?: number;
      // generalNotes?: string;
      // eventDate: Date;
    };

    // create check in
    await createEntity({
      body: dailyReportBody,
      auditUid: userId, // es el worker
      organizationId,
      entitySchemaWithFields: dailyReportsEntitySchemaWithFields,
    });
    return res.send({ success: true });
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.checkOut = async function (req, res) {
  try {
    const { userId, organizationId } = res.locals;
    const { patientId, itineraryId, itineraryType } = req.params;
    const { latitude, longitude } = req.body;

    await validateAllowCheckInOrOut({
      userId,
      organizationId,
      patientId,
      itineraryId,
      itineraryType,
      latitude,
      longitude,

      actionType: 'out',
    });

    // 1. actualizar daily report
    console.log('fetching schema by name: ' + CMSCollections.DAILY_REPORTS);

    const dailyReportsEntitySchemaWithFields = await fetchSchemaWithFields(
      null,
      organizationId,
      CMSCollections.DAILY_REPORTS
    );

    const dailyReportBody: IDailyReport = {
      userId: patientId,
      patientScheduleId: itineraryId,
      workerId: userId.id,
      dailyReportStatus: DailyReportStatusTypes.EMPTY,
      checkOutLatitude: latitude,
      checkOutLongitude: longitude,
      checkOut: new Date(Date.now()),
      eventDate: new Date(Date.now()),
      // globalScore?: number;
      // generalNotes?: string;
    };

    // create check in
    await createEntity({
      body: dailyReportBody,
      auditUid: userId, // es el worker
      organizationId,
      entitySchemaWithFields: dailyReportsEntitySchemaWithFields,
    });
    return res.send({ success: true });
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.createDailyReport = async function (req, res) {
  try {
    const { userId, organizationId } = res.locals;
    // const { patientId, itineraryId, itineraryType } = req.params;

    // 1. Obtengo worker relacionado al userId
    const worker = await fetchWorkerByUserId({ organizationId, userId });

    if (!worker) throw new Error('Missing worker (' + userId + ')');

    // 2. Obtengo relacion worker / patient
    // const patientWorkerRelationship = await fetchPatientWorkerActiveRelationship({
    //   organizationId,
    //   workerId: userId,
    //   patientId,
    // });

    // if (!patientWorkerRelationship) throw new Error('Missing patient worker relationship');

    // TODO
    // 1. get existent check in for this itinerary
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    // const itinerary = await fetchItinerary({ organizationId, itineraryId, itineraryType });

    return res.send({ success: true });
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};
