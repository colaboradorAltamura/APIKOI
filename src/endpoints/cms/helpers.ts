import { UserRolesHelper } from '../../helpers/userRolesHelper';
import { IUserBasicData, UserStatusTypes } from '../../types/@autogenerated';
import { Collections } from '../../types/collectionsTypes';
import { CustomError } from '../../vs-core';
import { COMPANY_EMPLOYEE_ROLE, buildUserSchemaWithFields } from '../../vs-core/helpers/schemas';
import { StateTypes } from '../../vs-core/types';
import { DynamicComponentTypes } from '../../vs-core/types/dynamics';
import {
  EntitySchemaTypes,
  IEntitySchema,
  IEntitySchemaField,
  IEntitySchemaFieldGroup,
  ISchemaWithFields,
  ISelectOptionEntity,
} from '../../vs-core/types/schemas';
import { IUser } from '../../vs-core/types/users';
import { createUser } from '../users/helpers';

const admin = require('firebase-admin');
const Joi = require('joi');

const usersSchemas = require('../users/schemas');
const schemas = require('./schemas');

const {
  sanitizeData,

  fetchSingleItem,
  updateSingleItem,

  listByPropInner,

  createFirestoreDocument,
} = require('../../vs-core-firebase/helpers/firestoreHelper');

interface ICreateArgs {
  id?: string;
  collectionName: string;
  itemData: any;
  auditUid: string;
  state?: StateTypes;
}

interface IUpdateArgs {
  id: string;
  collectionName: string;
  itemData: any;
  auditUid: string;
  state?: StateTypes; // no se usa en realidad. se usa el itemData. Lo dejo asi porque no me deja actualizar en processStateRelated
}

const userDataToUserEntitySchemaData = (userData: IUserBasicData) => {
  // y tmb como userId relacionado a esta entidad
  // le asigno los datos principales del usuario a esta entidad relacionada que tmb representa un usuario
  // TODO hacerlo de otra manera mas generica
  return {
    userId: userData.id,

    firstName: userData.firstName,
    lastName: userData.lastName,
    email: userData.email,
    phoneNumber: userData.phoneNumber ? userData.phoneNumber : null,
    identificationType: userData.identificationType ? userData.identificationType : null,
    identificationNumber: userData.identificationNumber ? userData.identificationNumber : null,
  };
};

const getUserByEmail = async (
  organizationId: string,
  email: string
): Promise<IUserBasicData | null> => {
  let firestoreUser = null;
  try {
    firestoreUser = await admin.auth().getUserByEmail(email);
  } catch (e) {
    if (e.code === 'auth/user-not-found') return null;
    throw e;
  }

  if (!firestoreUser) return null;

  const existentUser = await fetchSingleItem({
    collectionName: Collections.USERS,
    id: firestoreUser.uid,
  });

  if (!existentUser) throw new Error('Founded auth user but not fs user');

  return existentUser as IUserBasicData;
};

const getStateRelatedField: (entitySchemaWithFields) => IEntitySchemaField = (
  entitySchemaWithFields: ISchemaWithFields
) => {
  const stateRelatedField = entitySchemaWithFields.fields.find((field) => {
    return field.isRelatedStateOption && field.relationshipSchemaId;
  });

  return stateRelatedField;
};

const processStateRelated = async (
  entitySchemaWithFields: ISchemaWithFields,
  args: ICreateArgs | IUpdateArgs
) => {
  const stateRelatedField = getStateRelatedField(entitySchemaWithFields);

  if (stateRelatedField) {
    // stateRelatedFieldValue eg: deleted
    const stateRelatedFieldValue = args.itemData[stateRelatedField.name];

    if (stateRelatedFieldValue) {
      const stateRelatedOptionsSchema = await fetchSchema(
        null,
        entitySchemaWithFields.organizationId,
        null,
        stateRelatedField.relationshipSchemaId
      );

      const stateRelatedOption = (await fetchSingleItem({
        collectionName: stateRelatedOptionsSchema.collectionName,
        id: stateRelatedFieldValue,
      })) as ISelectOptionEntity;

      if (
        (stateRelatedOption.relatedState as any) !== '' &&
        stateRelatedOption.relatedState !== null &&
        typeof stateRelatedOption.relatedState !== 'undefined'
      ) {
        // se usa en el create
        args.state = parseInt(stateRelatedOption.relatedState as any);
        // se usa en el update
        args.itemData.state = parseInt(stateRelatedOption.relatedState as any);
      }
    }
  }
};

const processCreateRules = async (
  entitySchemaWithFields: ISchemaWithFields,
  createArgs: ICreateArgs
) => {
  await processStateRelated(entitySchemaWithFields, createArgs);

  entitySchemaWithFields.fields.forEach((field) => {
    if (!field.workflowRules) return;

    const _isCreating = true;
    const _currentValue = createArgs.itemData[field.name];
    const _allValues = createArgs;
    const _entitySchemaWithFields = entitySchemaWithFields;

    field.workflowRules.forEach((rule) => {
      console.log('Excecuting rule: ' + rule.name);

      eval(rule.ruleScript);
    });
  });
};

const processUpdateRules = async (
  entitySchemaWithFields: ISchemaWithFields,
  updateArgs: IUpdateArgs
) => {
  await processStateRelated(entitySchemaWithFields, updateArgs);

  entitySchemaWithFields.fields.forEach((field) => {
    if (!field.workflowRules) return;

    const _isUpdating = true;
    const _currentValue = updateArgs.itemData[field.name];
    const _allValues = updateArgs;
    const _entitySchemaWithFields = entitySchemaWithFields;

    field.workflowRules.forEach((rule) => {
      console.log('Excecuting rule: ' + rule.name);

      eval(rule.ruleScript);
    });
  });
};

const createValidationSchemaFromEntitySchema = (
  entitySchemaWithFields: ISchemaWithFields,
  isCreating: boolean
) => {
  // {
  //     id: zzz
  //     schemaId: xxx
  //     fieldType: string,
  //     fieldName: 'id'
  //     fieldRequiredCreate: bool
  //     fieldRequiredUpdate: bool
  // }

  const validationStructure = {};

  entitySchemaWithFields.fields.map((field) => {
    if (
      field.fieldType === DynamicComponentTypes.FORM_TEXT ||
      field.fieldType === DynamicComponentTypes.FORM_PHONE_NUMBER
    ) {
      validationStructure[field.name] = Joi.string().allow('');
    } else if (field.fieldType === DynamicComponentTypes.FORM_NUMBER) {
      validationStructure[field.name] = Joi.number().allow('');
    } else if (field.fieldType === DynamicComponentTypes.FORM_BOOLEAN) {
      validationStructure[field.name] = Joi.boolean();
    } else if (field.fieldType === DynamicComponentTypes.FORM_DATE) {
      validationStructure[field.name] = Joi.date().allow('', null);
    } else if (field.fieldType === DynamicComponentTypes.FORM_EMAIL) {
      validationStructure[field.name] = Joi.string().allow('').email({ minDomainSegments: 2 });
    } else if (
      field.fieldType === DynamicComponentTypes.FORM_MULTI_SELECT ||
      field.fieldType === DynamicComponentTypes.FORM_MULTI_SELECT_ASYNC ||
      field.fieldType === DynamicComponentTypes.FORM_MULTI_SELECT_CREATABLE ||
      field.fieldType === DynamicComponentTypes.FORM_COUNTRY_PICKER_CONSTRAINTS
    ) {
      validationStructure[field.name] = Joi.array().items(Joi.string());
    } else if (
      field.fieldType === DynamicComponentTypes.FORM_SELECT ||
      field.fieldType === DynamicComponentTypes.FORM_SELECT_ASYNC ||
      field.fieldType === DynamicComponentTypes.FORM_SELECT_CREATABLE ||
      field.fieldType === DynamicComponentTypes.FORM_COUNTRY_PICKER
    ) {
      validationStructure[field.name] = Joi.string().allow(null).allow('');
    } else if (
      field.fieldType === DynamicComponentTypes.RELATIONSHIP ||
      field.fieldType === DynamicComponentTypes.USER
    ) {
      validationStructure[field.name] = Joi.string();
    } else if (field.fieldType === DynamicComponentTypes.ADDRESS) {
      validationStructure[field.name] = Joi.object().allow(null);
    } else if (field.fieldType === DynamicComponentTypes.FORM_RELATED_STATE) {
      validationStructure[field.name] = Joi.string();
    } else if (field.fieldType === DynamicComponentTypes.FILE_UPLOADER) {
      validationStructure[field.name] = Joi.any();
      validationStructure[field.name + '_isPublic'] = Joi.boolean(); // agrego un field
    } else if (field.fieldType === DynamicComponentTypes.FORM_GENERIC_ANY) {
      validationStructure[field.name] = Joi.any();
    }

    if (!validationStructure[field.name]) {
      console.error('No validation for field ' + JSON.stringify(field));
      return;
    }

    if (field.isRequired && isCreating) {
      validationStructure[field.name] = validationStructure[field.name].required();
    }
  });

  return Joi.object({ ...validationStructure });
};

const processAndGetUserEntityCreation = async (
  auditUid: string,
  organizationId: string,
  entitySchema: IEntitySchema,
  createArgs: any
) => {
  try {
    const appUserStatus = UserStatusTypes.USER_STATUS_TYPE_ACTIVE;

    console.log('Sanitizing user create data: ' + JSON.stringify(createArgs));

    const userData = await sanitizeData({
      data: { appUserStatus, ...createArgs },
      validationSchema: usersSchemas.create,
    });

    let userEntity: IUserBasicData | null = null;

    try {
      userEntity = await getUserByEmail(organizationId, userData.email);
      console.log('User founded: ' + userData.email + ' > ' + userEntity.id);
    } catch (e) {}

    if (!userEntity) {
      console.log('User not found, creating user: ' + userData.email);

      userEntity = await createUser({
        auditUid,
        userData,
        appUserStatus,
        password: createArgs.password ? createArgs.password : null,
      });
    }

    const userId = userEntity.id;

    if (entitySchema.fixedRoleId) {
      console.log('Fetching user rols: ' + userId);

      const userRols = await UserRolesHelper.fetchUserRols({ organizationId, userId });

      const existsUserRole = userRols.find((userRol) => {
        return userRol.roleId === entitySchema.fixedRoleId;
      });

      if (!existsUserRole) {
        console.log('Sanitizing createUserRols');
        const userRolData = await sanitizeData({
          data: { organizationId, userId, roleId: entitySchema.fixedRoleId },
          validationSchema: schemas.createUserRols,
        });

        console.log('Creating user rol: ' + JSON.stringify(userRolData));

        await createFirestoreDocument({
          collectionName: Collections.USERS_ROLS,
          itemData: userRolData,
          auditUid,
          schemaId: null,
          documentId: null,
        });
      }
    }

    console.log('OK creating user: ' + userId);

    return userEntity;
  } catch (e) {
    console.error('Error creating or fetching related user entity');
    throw e;
  }
};

const fetchSchema: (
  res: any,
  organizationId: string,
  schemaName?: string,
  schemaId?: string
) => Promise<IEntitySchema> = async (res, organizationId, schemaName, schemaId) => {
  try {
    let theSchema = null;
    if (res && res.locals && res.locals.schema) {
      theSchema = res.locals.schema as IEntitySchema;
    } else {
      if (!organizationId) throw new Error('Missing organization id');
      if (!schemaName && !schemaId) throw new Error('Missing schema name or id');

      const db = admin.firestore();
      let querySnapshotSchema = null;

      if (schemaName === Collections.USERS || schemaId === Collections.USERS) {
        return buildUserSchemaWithFields(organizationId);
      }

      // if (
      //   schemaName === Collections.COMPANIES ||
      //   schemaId === organizationId + '_' + Collections.COMPANIES
      // ) {
      //   return buildCompanySchemaWithFields(organizationId);
      // }

      // if (
      //   schemaName === Collections.COMPANY_EMPLOYEES ||
      //   schemaId === organizationId + '_' + Collections.COMPANY_EMPLOYEES
      // ) {
      //   return buildCompanyEmployeesSchemaWithFields(organizationId);
      // }

      console.log('Fetching schema by name:', schemaName, 'ById: ', schemaId);
      if (schemaName) {
        querySnapshotSchema = await db
          .collection(Collections.SCHEMAS)
          .where('organizationId', '==', organizationId)
          .where('name', '==', schemaName)
          .get();
      } else {
        querySnapshotSchema = await db
          .collection(Collections.SCHEMAS)
          .where('organizationId', '==', organizationId)
          .where('id', '==', schemaId)
          .get();
      }

      if (querySnapshotSchema.empty || querySnapshotSchema.docs.length !== 1) {
        throw new Error('Invalid schemaName (' + schemaName + ') for org: ' + organizationId);
      }

      theSchema = { ...querySnapshotSchema.docs[0].data(), id: querySnapshotSchema.docs[0].id };
    }

    if (theSchema.createdAt) theSchema.createdAt = theSchema.createdAt.toDate();
    if (theSchema.updatedAt) theSchema.updatedAt = theSchema.updatedAt.toDate();

    return theSchema as IEntitySchema;
  } catch (err) {
    console.error(
      'Error fetch schema with args: ' + JSON.stringify({ organizationId, schemaName })
    );
    throw new CustomError.TechnicalError('ERROR_FETCH_SCHEMA_SIMPLE', null, err.message, err);
  }
};

const fetchSchemaWithFields: (
  res: any,
  organizationId: string,
  schemaName?: string,
  schemaId?: string
) => Promise<ISchemaWithFields> = async (res, organizationId, schemaName, schemaId) => {
  const theSchema = (await fetchSchema(
    res,
    organizationId,
    schemaName,
    schemaId
  )) as ISchemaWithFields;
  try {
    const relatedFields = await listByPropInner({
      limit: 1000,
      offset: 0,
      filters: null,

      primaryEntityPropName: 'schemaId',
      primaryEntityValue: theSchema.id,

      listByCollectionName: Collections.SCHEMA_FIELDS,
      indexedFilters: ['schemaId'],
    });

    theSchema.fields = relatedFields.items;

    // TODO - Esto esta feo, lo hago porque la coleccion de users no existe en los schemas, sino que es forzado
    theSchema.fields.forEach((field) => {
      if (field.relationshipSchemaId === Collections.USERS) {
        if (!field['@dependencies']) field['@dependencies'] = {};
        field['@dependencies']['relationshipSchemaId_SOURCE_ENTITIES'] = [
          { id: Collections.USERS, name: Collections.USERS, collectionName: Collections.USERS },
        ];
      }

      // if (field.relationshipSchemaId === Collections.COMPANIES) {
      //   if (!field['@dependencies']) field['@dependencies'] = {};
      //   field['@dependencies']['relationshipSchemaId_SOURCE_ENTITIES'] = [
      //     {
      //       id: Collections.COMPANIES,
      //       name: Collections.COMPANIES,
      //       collectionName: Collections.COMPANIES,
      //     },
      //   ];
      // }
    });

    // agrego los fields de user a las colecciones que son de tipo USER_ENTITY o COMPANY_EMPLOYEES_ENTITY
    if (
      theSchema.schemaType === EntitySchemaTypes.USER_ENTITY ||
      theSchema.schemaType === EntitySchemaTypes.COMPANY_EMPLOYEES_ENTITY
    ) {
      const userSchema = buildUserSchemaWithFields(organizationId);

      userSchema.fields.forEach((userField) => {
        theSchema.fields.push({ ...userField, schemaId: theSchema.id });
      });
    }

    return theSchema as ISchemaWithFields;
  } catch (err) {
    console.error(
      'Error fetch schema with args: ' + JSON.stringify({ organizationId, schemaName })
    );
    throw new CustomError.TechnicalError('ERROR_FETCH_SCHEMA_FIELDS', null, err.message, err);
  }
};

const fetchSchemaFieldGroups: (schemaId?: string) => Promise<IEntitySchemaFieldGroup> = async (
  schemaId
) => {
  try {
    const relatedFields = await listByPropInner({
      limit: 1000,
      offset: 0,
      filters: null,

      primaryEntityPropName: 'schemaId',
      primaryEntityValue: schemaId,

      listByCollectionName: Collections.SCHEMA_FIELD_GROUPS,
      indexedFilters: ['schemaId'],
    });

    return relatedFields;
  } catch (err) {
    console.error('Error fetch schema with args: ' + JSON.stringify({ schemaId }));
    throw new CustomError.TechnicalError('ERROR_FETCH_SCHEMA_FIELD_GROUPS', null, err.message, err);
  }
};

const fetchOrganizationSchemas = async ({ organizationId }) => {
  try {
    if (!organizationId) throw new Error('Missing organization id');

    const db = admin.firestore();
    const querySnapshot = await db
      .collection(Collections.SCHEMAS)
      .where('organizationId', '==', organizationId)
      .get();

    if (!querySnapshot.docs || !querySnapshot.docs.length) return [];
    // let querySnapshot = null;
    // if (typeof filterState !== 'undefined' && filterState !== null)
    //   querySnapshot = await ref
    //     .where('state', '==', filterState)
    //     .limit(limit)
    //     .orderBy('createdAt', 'asc')
    //     .get();
    // else querySnapshot = await ref.limit(limit).orderBy('createdAt', 'asc').get();

    const items = querySnapshot.docs.map((doc) => {
      const id = doc.id;
      const data = doc.data();

      if (data.createdAt) data.createdAt = data.createdAt.toDate();
      if (data.updatedAt) data.updatedAt = data.updatedAt.toDate();

      return { ...data, id };
    });

    items.sort((aa, bb) => {
      return bb.createdAt - aa.createdAt;
    });

    const usersSchema = buildUserSchemaWithFields(organizationId);
    delete usersSchema.fields;

    // const companiesSchema = buildCompanySchemaWithFields(organizationId);
    // delete companiesSchema.fields;

    // const companyEmployeesSchema = buildCompanyEmployeesSchemaWithFields(organizationId);
    // delete companyEmployeesSchema.fields;

    items.push(usersSchema);
    // items.push(companiesSchema);
    // items.push(companyEmployeesSchema);

    return items;
  } catch (err) {
    console.error('Error fetch schema with args: ' + JSON.stringify({ organizationId }));
    throw new CustomError.TechnicalError('ERROR_FETCH_SCHEMAS', null, err.message, err);
  }
};

const fetchOrganizationRols = async ({ organizationId }) => {
  try {
    if (!organizationId) throw new Error('Missing organization id');

    const compEmployeeRole = {
      organizationId,
      relatedSchemaId: '',
      updatedBy: 'sys-admin',
      createdBy: 'sys-admin',
      name: COMPANY_EMPLOYEE_ROLE,
      id: COMPANY_EMPLOYEE_ROLE,
      state: StateTypes.STATE_ACTIVE,
      isSchemaRelated: false,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    const db = admin.firestore();
    const querySnapshot = await db
      .collection(Collections.ORGANIZATION_USER_DEFINED_ROLS)
      .where('organizationId', '==', organizationId)
      .get();

    if (!querySnapshot.docs || !querySnapshot.docs.length) return [compEmployeeRole];
    // let querySnapshot = null;
    // if (typeof filterState !== 'undefined' && filterState !== null)
    //   querySnapshot = await ref
    //     .where('state', '==', filterState)
    //     .limit(limit)
    //     .orderBy('createdAt', 'asc')
    //     .get();
    // else querySnapshot = await ref.limit(limit).orderBy('createdAt', 'asc').get();

    const items = querySnapshot.docs.map((doc) => {
      const id = doc.id;
      const data = doc.data();

      if (data.createdAt) data.createdAt = data.createdAt.toDate();
      if (data.updatedAt) data.updatedAt = data.updatedAt.toDate();

      return { ...data, id };
    });

    items.sort((aa, bb) => {
      return bb.createdAt - aa.createdAt;
    });

    items.push(compEmployeeRole);

    return items;
  } catch (err) {
    console.error(
      'Error fetch org user defined rols with args: ' + JSON.stringify({ organizationId })
    );
    throw new CustomError.TechnicalError(
      'ERROR_FETCH_ORG_USER_DEFINED_ROLS',
      null,
      err.message,
      err
    );
  }
};

const getQueryRelationships = async (
  entitySchemaWithFields: ISchemaWithFields,
  organizationId: string,
  fields: string[] | null
) => {
  const allSchemas = await fetchOrganizationSchemas({ organizationId });

  const queryRelationships = [];

  // si no define fields entonces traigo todos
  if (!fields) {
    fields = entitySchemaWithFields.fields.map((field) => {
      return field.name;
    });
  }

  // console.log('Query with fields: ', JSON.stringify(fields));

  if (fields) {
    fields.forEach((field) => {
      const entitySchemaField = entitySchemaWithFields.fields.find((entityField) => {
        return field === entityField.name;
      });

      if (!entitySchemaField) return;

      if (
        entitySchemaField.fieldType === DynamicComponentTypes.FORM_MULTI_SELECT_ASYNC ||
        entitySchemaField.fieldType === DynamicComponentTypes.FORM_SELECT_ASYNC
      ) {
        const schema = allSchemas.find((schema) => {
          return schema.id === entitySchemaField.relationshipSchemaId;
        });

        if (!schema) {
          throw new Error(
            'Missing schema with id: ' +
              entitySchemaField.relationshipSchemaId +
              ' from field: ' +
              entitySchemaField.id +
              ' (' +
              entitySchemaField.name +
              ')'
          );
        }

        queryRelationships.push({
          collectionName: schema.collectionName,
          propertyName: entitySchemaField.name,
        });
      } else if (
        // entitySchemaWithFields.schemaType === EntitySchemaTypes.RELATIONSHIP_USER2USER_ENTITY ||
        // (entitySchemaWithFields.schemaType === EntitySchemaTypes.USER_ENTITY &&
        entitySchemaField.fieldType === DynamicComponentTypes.USER
        // )
      ) {
        queryRelationships.push({
          collectionName: Collections.USERS,
          propertyName: entitySchemaField.name,
        });
      } else if (
        // si el schema es de tipo relacion (eg: userProducts o patientTerapeuts o usersByStaff)
        // y el field es el "target" de la relacion (eg: relationshipTargetSchemaId seria 'products')
        // entonces agrego a la query esta relacion (productId (relationshipTargetSchemaId) > viaja como dependency)
        entitySchemaField.fieldType === DynamicComponentTypes.RELATIONSHIP &&
        (entitySchemaField.relationshipSchemaId ===
          entitySchemaWithFields.relationshipTargetSchemaId ||
          entitySchemaWithFields.bidirectional)
        // LO De ABAJO REEMPLAZADO POR USER2USER
        // si el schema es de tipo relacion (eg: patientTerapeuts o usersByStaff)
        // y la relacion es entre 2 entidades usuario (user2user)
        // entonces agrego a la query esta relacion (terapeutId (relationshipTargetSchemaId) > viaja como dependency)
        // || (entitySchemaField.fieldType === DynamicComponentTypes.RELATIONSHIP &&
        //   entitySchemaWithFields.relationshipSourceRequiredRols &&
        //   entitySchemaWithFields.relationshipTargetRequiredRols &&
        //   entitySchemaField.relationshipSchemaId ===
        //     entitySchemaWithFields.relationshipSourceSchemaId)
      ) {
        let schema = null;

        const usersSchema = buildUserSchemaWithFields(organizationId);
        // const companiesSchema = buildUserSchemaWithFields(organizationId);
        if (entitySchemaField.relationshipSchemaId === usersSchema.id) {
          schema = usersSchema;
        }
        //  else if (entitySchemaField.relationshipSchemaId === companiesSchema.id) {
        //   schema = companiesSchema;
        // }
        else {
          schema = allSchemas.find((schema) => {
            return schema.id === entitySchemaField.relationshipSchemaId;
          });
        }

        if (!schema) {
          throw new Error(
            'Missing schema with id: ' +
              entitySchemaField.relationshipSchemaId +
              ' from field: ' +
              entitySchemaField.id +
              ' (' +
              entitySchemaField.name +
              ')'
          );
        }

        queryRelationships.push({
          collectionName: schema.collectionName,
          propertyName: entitySchemaField.name,
        });
      }
    });
  }

  console.log('Query with relationships: ', JSON.stringify(queryRelationships));

  return queryRelationships;
};

const hasRole = (rolsList: string[], rol: string) => {
  return rolsList.indexOf(rol) > -1;
};

const user2UserIsSource = async (
  organizationId: string,
  userId: string,
  entitySchema: IEntitySchema
) => {
  const userDefinedRols = await UserRolesHelper.fetchUserRols({ organizationId, userId });

  let currentEntityIsSource = true;
  // Si es un User2User quiere decir que estoy consultando desde uno de los 2,
  // tengo que identificar si desde el que estoy consultando es source o target

  if (
    entitySchema &&
    entitySchema.relationshipTargetRequiredRols &&
    entitySchema.relationshipSourceSchemaId
  ) {
    if (userDefinedRols) {
      // si tiene un rol de los requeridos en el target entonces NO es source
      entitySchema.relationshipTargetRequiredRols.forEach((targetRequiredRole) => {
        if (hasRole(userDefinedRols, targetRequiredRole)) {
          currentEntityIsSource = false;
        }
      });
    }
  }

  return currentEntityIsSource;
};

const getFirebaseUserByEmailOrNull = async (email) => {
  try {
    const firestoreUser = await admin.auth().getUserByEmail(email);
    return firestoreUser;
  } catch (e) {
    if (e.code === 'auth/user-not-found') return null;
    throw e;
  }
};

const processAndPatchUserEntityUpdate = async (
  auditUid: string,
  organizationId: string,
  entitySchema: IEntitySchema,
  id: string,
  updateArgs: any
) => {
  try {
    console.log('Sanitizing user update data: ' + JSON.stringify(updateArgs));

    const sanitizedData = await sanitizeData({
      data: updateArgs,
      validationSchema: usersSchemas.updateCurrentSchema,
    });

    let existentUser = await fetchSingleItem({
      collectionName: Collections.USERS,
      id,
    });

    if (sanitizedData.email) {
      if (existentUser.email !== sanitizedData.email) {
        console.log(`Changing email from : ${existentUser.email} to ${sanitizedData.email}`);
        const existentUserByEmail = await getFirebaseUserByEmailOrNull(sanitizedData.email);

        if (existentUserByEmail) throw new Error('Email exits for other user');

        await admin.auth().updateUser(id, {
          // displayName: existentUser.firstName + ' ' + existentUser.lastName,

          email: sanitizedData.email,
        });
      }
    }

    // TODO MICHEL QUE HAGO PARA VALIDAR ESTO
    await updateSingleItem({
      collectionName: Collections.USERS,
      id,
      data: sanitizedData,
      auditUid,
    });

    existentUser = { ...existentUser, ...sanitizedData };

    console.log('OK updating user: ' + JSON.stringify(existentUser));

    return existentUser as IUser;
  } catch (e) {
    console.error('Error creating or fetching related user entity');
    throw e;
  }
};

const createEntity = async ({
  body,
  auditUid,
  organizationId,
  entitySchemaWithFields,
}: {
  body: any;
  auditUid: string;
  organizationId: string;
  entitySchemaWithFields: ISchemaWithFields;
}): Promise<any> => {
  const validationSchema = createValidationSchemaFromEntitySchema(entitySchemaWithFields, true);
  const collectionName = entitySchemaWithFields.collectionName;

  console.log('Create args (' + collectionName + '):', JSON.stringify(body));

  const itemData = await sanitizeData({ data: body, validationSchema });

  // cuando se crea se deja el schema id como referencia del registro
  itemData['@schemaId'] = entitySchemaWithFields.id;

  const createArgs: ICreateArgs = {
    collectionName,
    itemData,
    auditUid,
  };

  if (entitySchemaWithFields.schemaType === EntitySchemaTypes.USER_ENTITY) {
    // busca o crea el usuario, retorna el id que lo uso como id de esta entidad
    const userEntity = await processAndGetUserEntityCreation(
      auditUid,
      organizationId,
      entitySchemaWithFields,
      body
    );

    createArgs.id = userEntity.id;

    // le asigno los datos principales de la coleccion de usuario a la entidad creada, esto es para busqueda
    createArgs.itemData = {
      ...userDataToUserEntitySchemaData(userEntity),
      ...createArgs.itemData,
    };
  } else if (entitySchemaWithFields.schemaType === EntitySchemaTypes.COMPANY_ENTITY) {
    // TODO
  } else if (entitySchemaWithFields.schemaType === EntitySchemaTypes.SELECT_OPTIONS_ENTITY) {
    const CODE_PROP_NAME = 'code';

    const codeField = entitySchemaWithFields.fields.find((field) => {
      return field.name === CODE_PROP_NAME;
    });

    if (codeField) {
      createArgs.id = itemData[codeField.name];
    }

    console.log('Creating SELECT_OPTIONS_ENTITY:' + JSON.stringify(createArgs));
  } else if (entitySchemaWithFields.schemaType === EntitySchemaTypes.COMPANY_EMPLOYEES_ENTITY) {
    // busca o crea el usuario, retorna el id que lo uso como id de esta entidad
    const userEntity = await processAndGetUserEntityCreation(
      auditUid,
      organizationId,
      entitySchemaWithFields,
      body
    );

    // le asigno los datos principales de la coleccion de usuario a la entidad creada, esto es para busqueda
    createArgs.itemData = {
      ...userDataToUserEntitySchemaData(userEntity),
      ...createArgs.itemData,
    };
  }

  await processCreateRules(entitySchemaWithFields, createArgs);

  console.log('Creating with args: ' + JSON.stringify(createArgs));

  const dbItemData = await createFirestoreDocument(createArgs);

  console.log('Created data: (' + collectionName + ')', JSON.stringify(dbItemData));

  return dbItemData;
};

const updateEntity = async ({
  id,
  body,
  auditUid,
  organizationId,
  entitySchemaWithFields,
}: {
  id: string;
  body: any;
  auditUid: string;
  organizationId: string;
  entitySchemaWithFields: ISchemaWithFields;
}): Promise<any> => {
  if (!id) throw new CustomError.TechnicalError('ERROR_MISSING_ARGS', null, 'Invalid args', null);
  console.log('hola');
  const validationSchema = createValidationSchemaFromEntitySchema(entitySchemaWithFields, false);
  const collectionName = entitySchemaWithFields.collectionName;

  console.log('Patch args (' + collectionName + '):' + JSON.stringify(body));

  const itemData = await sanitizeData({ data: body, validationSchema });

  const updateArgs: IUpdateArgs = { collectionName, id, itemData, auditUid };
  if (entitySchemaWithFields.schemaType === EntitySchemaTypes.USER_ENTITY) {
    // busca o crea el usuario, retorna el id que lo uso como id de esta entidad
    const updatedUserData = await processAndPatchUserEntityUpdate(
      auditUid,
      organizationId,
      entitySchemaWithFields,
      id,
      body
    );

    updateArgs.itemData = {
      ...userDataToUserEntitySchemaData(updatedUserData),
      ...updateArgs.itemData,
    };
  }

  await processUpdateRules(entitySchemaWithFields, updateArgs);

  console.log('Updating data with args: ' + JSON.stringify(updateArgs));

  const dbItemData = await updateSingleItem(updateArgs);

  console.log('Patch done: (' + collectionName + ')');

  return dbItemData;
};

export {
  createEntity,
  updateEntity,
  ICreateArgs,
  IUpdateArgs,
  fetchSchemaWithFields,
  fetchOrganizationSchemas,
  fetchSchemaFieldGroups,
  fetchOrganizationRols,
  getQueryRelationships,
  user2UserIsSource,
};
