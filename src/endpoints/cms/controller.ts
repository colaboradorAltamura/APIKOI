import { buildUserSchemaWithFields } from '../../vs-core/helpers/schemas';

import { Collections } from '../../types/collectionsTypes';
import { creationStruct, updateStruct } from '../../vs-core-firebase/audit';
import {
  deleteLogicalSingleItem,
  deleteSingleItem,
  fillItemsWithRelationships,
  getWithRelationships,
} from '../../vs-core-firebase/helpers/firestoreHelper';
import { StateTypes } from '../../vs-core/types';
import { EntitySchemaTypes, IEntitySchema, IEntitySchemaField } from '../../vs-core/types/schemas';

import { EMAIL_INBOX_ADMISSION } from '../../config/appConfig';
import { nameof } from '../../helpers/coreHelper';
import {
  CMSCollections,
  IApplicant,
  IEntity,
  IUserBasicData,
  IUsersAddress,
} from '../../types/@autogenerated';
import { EmailSender } from '../../vs-core-firebase';
import {
  IUpdateArgs,
  createEntity,
  fetchOrganizationRols,
  fetchOrganizationSchemas,
  fetchSchemaFieldGroups,
  fetchSchemaWithFields,
  getQueryRelationships,
  updateEntity,
  user2UserIsSource,
} from './helpers';

// eslint-disable-next-line import/no-extraneous-dependencies, import/named
import { Geopoint, distanceBetween, geohashQueryBounds } from 'geofire-common';

import { listWithRelationshipsV2 } from '../../vs-core-firebase/helpers/firestoreHelperWorker';

const { processSchemaFieldItems, processSchemaFieldItem } = require('../../helpers/coreHelper');
/* eslint-disable no-unused-vars */

const admin = require('firebase-admin');
const functions = require('firebase-functions');

const { ErrorHelper } = require('../../vs-core-firebase');

const { Types } = require('../../vs-core');

const { CustomError } = require('../../vs-core');

const cmsValidationSchemas = require('./schemas');

const {
  sanitizeData,

  fetchSingleItem,
  updateSingleItem,
  listWithRelationships,
  listByPropInner,

  createFirestoreDocument,
} = require('../../vs-core-firebase/helpers/firestoreHelper');

exports.fetchCacheableEntitiesData = async function (req, res) {
  try {
    // NOT IMPLEMENTED
    return res.send(null);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

// ** <FIND> **
// /cms/pathologies?fields[]=type >> find
exports.find = async function (req, res) {
  try {
    const { organizationId } = res.locals;
    const { schemaName, schemaId } = req.params; // pathologies

    // res.startTime('db', 'File DB metric');
    const entitySchemaWithFields = await fetchSchemaWithFields(
      res,
      organizationId,
      schemaName,
      schemaId
    );

    const { limit, offset } = req.query;

    let { fields, filters } = req.query;

    if (!filters) filters = {};
    if (!filters.state) filters.state = { $equal: Types.StateTypes.STATE_ACTIVE };

    const queryRelationships = await getQueryRelationships(
      entitySchemaWithFields,
      organizationId,
      fields
    );

    let result = null;

    // if (entitySchemaWithFields.schemaType === EntitySchemaTypes.RELATIONSHIP_USER2USER_ENTITY) {

    if (schemaName === 'workers') {
      result = await listWithRelationshipsV2({
        limit,
        offset,
        filters,
        listByCollectionName: entitySchemaWithFields.collectionName,
        indexedFilters: entitySchemaWithFields.indexedFilters,
        indexedCompoundFilters: entitySchemaWithFields.indexedCompoundFilters,
        relationships: queryRelationships,
      });
    } else {
      // consulto por relaciones
      result = await listWithRelationships({
        limit,
        offset,
        filters,

        listByCollectionName: entitySchemaWithFields.collectionName,
        indexedFilters: entitySchemaWithFields.indexedFilters,
        relationships: queryRelationships,
      });
    }
    // res.endTime('db');

    processSchemaFieldItems(result.items, entitySchemaWithFields.fields);

    result.entitySchema = entitySchemaWithFields;

    return res.send(result);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

// /cms/userPathologies/mine?fields[]=type
exports.findMine = async function (req, res) {
  try {
    const { userId, organizationId } = res.locals;
    const { schemaName, schemaId } = req.params; // userPathologies

    const entitySchemaWithFields = await fetchSchemaWithFields(
      res,
      organizationId,
      schemaName,
      schemaId
    );

    const { limit, offset } = req.query;

    let { filters, fields } = req.query;

    if (!filters) filters = {};
    if (!filters.state) filters.state = { $equal: Types.StateTypes.STATE_ACTIVE };

    const queryRelationships = await getQueryRelationships(
      entitySchemaWithFields,
      organizationId,
      fields
    );

    // consulto por relaciones
    const result = await listByPropInner({
      limit,
      offset,
      filters,

      primaryEntityPropName: 'userId',
      primaryEntityValue: userId,

      listByCollectionName: entitySchemaWithFields.collectionName,
      indexedFilters: entitySchemaWithFields.indexedFilters,
      relationships: queryRelationships,
    });

    processSchemaFieldItems(result.items, entitySchemaWithFields.fields);

    result.entitySchema = entitySchemaWithFields;

    return res.send(result);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

// /cms/userPathologies/by-user/:userId?fields[]=type >> findByStaff
exports.findByUser = async function (req, res) {
  try {
    const { organizationId } = res.locals;
    const { schemaName, schemaId, userId } = req.params; // userPathologies

    const entitySchemaWithFields = await fetchSchemaWithFields(
      res,
      organizationId,
      schemaName,
      schemaId
    );

    const { limit, offset } = req.query;
    let { filters, fields } = req.query;

    if (!filters) filters = {};
    if (!filters.state) filters.state = { $equal: Types.StateTypes.STATE_ACTIVE };

    const queryRelationships = await getQueryRelationships(
      entitySchemaWithFields,
      organizationId,
      fields
    );

    let userFieldPropName = 'userId';
    if (entitySchemaWithFields.schemaType === EntitySchemaTypes.RELATIONSHIP_USER2USER_ENTITY) {
      const userIsSource = await user2UserIsSource(organizationId, userId, entitySchemaWithFields);

      if (userIsSource) {
        if (!entitySchemaWithFields.relationshipSourceSchemaId) {
          throw new Error('missing relationshipSourceSchemaId in ' + entitySchemaWithFields.name);
        }
        const field = entitySchemaWithFields.fields.find((field) => {
          return field.relationshipSchemaId === entitySchemaWithFields.relationshipSourceSchemaId;
        });

        if (!field) {
          throw new Error(
            'Missing field with id: ' +
              entitySchemaWithFields.relationshipSourceSchemaId +
              ' in ' +
              entitySchemaWithFields.name
          );
        }

        userFieldPropName = field.name;
      } else {
        if (!entitySchemaWithFields.relationshipTargetSchemaId) {
          throw new Error('missing relationshipTargetSchemaId in ' + entitySchemaWithFields.name);
        }

        const field = entitySchemaWithFields.fields.find((field) => {
          return field.relationshipSchemaId === entitySchemaWithFields.relationshipTargetSchemaId;
        });

        if (!field) {
          throw new Error(
            'Missing field with id: ' +
              entitySchemaWithFields.relationshipTargetSchemaId +
              ' in ' +
              entitySchemaWithFields.name
          );
        }

        userFieldPropName = field.name;
      }
    }

    console.log('query by field:' + userFieldPropName);

    // consulto por relaciones
    const result = await listByPropInner({
      limit,
      offset,
      filters,

      primaryEntityPropName: userFieldPropName,
      primaryEntityValue: userId,

      listByCollectionName: entitySchemaWithFields.collectionName,
      indexedFilters: [userFieldPropName], // entitySchemaWithFields.indexedFilters, // TODO Michel - deerian venir por definicion desde el schema, de ultima hacer un join
      relationships: queryRelationships,
    });

    processSchemaFieldItems(result.items, entitySchemaWithFields.fields);

    result.entitySchema = entitySchemaWithFields;

    return res.send(result);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

// /cms/companyClients/by-company/:companyId?fields[]=type >> findByCompany
exports.findByCompany = async function (req, res) {
  try {
    const { organizationId } = res.locals;
    const { schemaName, schemaId, companyId } = req.params; // companyClients

    const entitySchemaWithFields = await fetchSchemaWithFields(
      res,
      organizationId,
      schemaName,
      schemaId
    );

    const { limit, offset } = req.query;
    let { filters, fields } = req.query;

    if (!filters) filters = {};
    if (!filters.state) filters.state = { $equal: Types.StateTypes.STATE_ACTIVE };

    const queryRelationships = await getQueryRelationships(
      entitySchemaWithFields,
      organizationId,
      fields
    );

    console.log(
      'entitySchemaWithFields:',
      entitySchemaWithFields,
      'queryRelationships:',
      queryRelationships
    );

    // consulto por relaciones
    const result = await listByPropInner({
      limit,
      offset,
      filters,

      primaryEntityPropName: 'companyId',
      primaryEntityValue: companyId,

      listByCollectionName: entitySchemaWithFields.collectionName,
      indexedFilters: entitySchemaWithFields.indexedFilters,
      relationships: queryRelationships,
    });

    processSchemaFieldItems(result.items, entitySchemaWithFields.fields);

    result.entitySchema = entitySchemaWithFields;

    return res.send(result);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

// /cms/pathologyTreatments/by-prop/:id/:propName?fields[]=type >> findById
exports.findByProp = async function (req, res) {
  try {
    const { organizationId } = res.locals;
    const { schemaName, schemaId, propValue, propName } = req.params; // pathologyTreatments

    const entitySchemaWithFields = await fetchSchemaWithFields(
      res,
      organizationId,
      schemaName,
      schemaId
    );

    const { limit, offset } = req.query;
    let { filters, fields } = req.query;

    if (!filters) filters = {};
    if (!filters.state) filters.state = { $equal: Types.StateTypes.STATE_ACTIVE };

    const queryRelationships = await getQueryRelationships(
      entitySchemaWithFields,
      organizationId,
      fields
    );

    // consulto por relaciones
    const result = await listByPropInner({
      limit,
      offset,
      filters,

      primaryEntityPropName: propName,
      primaryEntityValue: propValue,

      listByCollectionName: entitySchemaWithFields.collectionName,
      indexedFilters: entitySchemaWithFields.indexedFilters,
      relationships: queryRelationships,
    });

    processSchemaFieldItems(result.items, entitySchemaWithFields.fields);

    result.entitySchema = entitySchemaWithFields;

    return res.send(result);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

// ** </FIND> **

// ** <GET> **
// /cms/pathologies/:id?fields[]=type >> get
exports.get = async function (req, res) {
  try {
    const { organizationId } = res.locals;
    const { schemaName, schemaId, id } = req.params;

    console.log('Get entered');

    if (!id) {
      throw new CustomError.TechnicalError(
        'ERROR_MISSING_ARGS',
        null,
        'Id or schema not recived',
        null
      );
    }

    const entitySchemaWithFields = await fetchSchemaWithFields(
      res,
      organizationId,
      schemaName,
      schemaId
    );

    let { filters, fields } = req.query;

    if (!filters) filters = {};
    if (!filters.state) filters.state = { $equal: Types.StateTypes.STATE_ACTIVE };

    const queryRelationships = await getQueryRelationships(
      entitySchemaWithFields,
      organizationId,
      fields
    );

    const item = await getWithRelationships({
      id,
      collectionName: entitySchemaWithFields.collectionName,
      relationships: queryRelationships,
      postProcessor: null,
    });

    processSchemaFieldItem(item, entitySchemaWithFields.fields);

    console.log('OK - get (' + entitySchemaWithFields.collectionName + ')' + JSON.stringify(item));

    const result = item;

    return res.send(result);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.getMine = async function (req, res) {
  try {
    const { organizationId, userId } = res.locals;
    const { schemaName, schemaId, id } = req.params;

    console.log('Get entered');

    if (!id) {
      throw new CustomError.TechnicalError(
        'ERROR_MISSING_ARGS',
        null,
        'Id or schema not recived',
        null
      );
    }

    const entitySchemaWithFields = await fetchSchemaWithFields(
      res,
      organizationId,
      schemaName,
      schemaId
    );

    const { fields } = req.query;

    const queryRelationships = await getQueryRelationships(
      entitySchemaWithFields,
      organizationId,
      fields
    );

    const item = (await getWithRelationships({
      id,
      collectionName: entitySchemaWithFields.collectionName,
      relationships: queryRelationships,
      postProcessor: null,
    })) as any;

    processSchemaFieldItem(item, entitySchemaWithFields.fields);

    console.log('OK - get (' + entitySchemaWithFields.collectionName + ')' + JSON.stringify(item));

    if (item.userId !== userId) {
      throw new Error('Get mine requires same userId');
    }

    const result = item;

    return res.send(result);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.getByUser = async function (req, res) {
  try {
    const { organizationId } = res.locals;
    const { schemaName, schemaId, id, userId } = req.params;

    console.log('Get entered');

    if (!id) {
      throw new CustomError.TechnicalError(
        'ERROR_MISSING_ARGS',
        null,
        'Id or schema not recived',
        null
      );
    }

    const entitySchemaWithFields = await fetchSchemaWithFields(
      res,
      organizationId,
      schemaName,
      schemaId
    );

    const { fields } = req.query;

    const queryRelationships = await getQueryRelationships(
      entitySchemaWithFields,
      organizationId,
      fields
    );

    const item = (await getWithRelationships({
      id,
      collectionName: entitySchemaWithFields.collectionName,
      relationships: queryRelationships,
      postProcessor: null,
    })) as any;

    processSchemaFieldItem(item, entitySchemaWithFields.fields);

    console.log('OK - get (' + entitySchemaWithFields.collectionName + ')' + JSON.stringify(item));

    if (item.userId !== userId) {
      throw new Error('Get by user requires same userId recived by param');
    }

    const result = item;

    return res.send(result);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.getByCompany = async function (req, res) {
  try {
    const { organizationId } = res.locals;
    const { schemaName, schemaId, id, companyId } = req.params;

    console.log('Get entered');

    if (!id) {
      throw new CustomError.TechnicalError(
        'ERROR_MISSING_ARGS',
        null,
        'Id or schema not recived',
        null
      );
    }

    const entitySchemaWithFields = await fetchSchemaWithFields(
      res,
      organizationId,
      schemaName,
      schemaId
    );

    const { fields } = req.query;

    const queryRelationships = await getQueryRelationships(
      entitySchemaWithFields,
      organizationId,
      fields
    );

    const item = (await getWithRelationships({
      id,
      collectionName: entitySchemaWithFields.collectionName,
      relationships: queryRelationships,
      postProcessor: null,
    })) as any;

    processSchemaFieldItem(item, entitySchemaWithFields.fields);

    console.log('OK - get (' + entitySchemaWithFields.collectionName + ')' + JSON.stringify(item));

    if (item.companyId !== companyId) {
      throw new Error('Get by company requires same companyId');
    }

    const result = item;

    return res.send(result);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

// ** </GET> **

// ** <PATCH> **
exports.patch = async function (req, res) {
  try {
    console.log('Patch entered');

    const { userId, organizationId } = res.locals;
    const { schemaName, schemaId, id } = req.params; // pathologies
    const auditUid = userId;
    const body = req.body;

    if (!id) throw new CustomError.TechnicalError('ERROR_MISSING_ARGS', null, 'Invalid args', null);

    const entitySchemaWithFields = await fetchSchemaWithFields(
      res,
      organizationId,
      schemaName,
      schemaId
    );

    const dbItemData = await updateEntity({
      id,
      body,
      auditUid,
      organizationId,
      entitySchemaWithFields,
    });

    return res.status(204).send(dbItemData);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.patchMine = async function (req, res) {
  try {
    console.log('Patch mine entered');

    const { userId, organizationId } = res.locals;
    const { schemaName, schemaId, id } = req.params; // pathologies
    const auditUid = userId;
    const body = req.body;

    if (!id) throw new CustomError.TechnicalError('ERROR_MISSING_ARGS', null, 'Invalid args', null);

    const entitySchemaWithFields = await fetchSchemaWithFields(
      res,
      organizationId,
      schemaName,
      schemaId
    );

    const collectionName = entitySchemaWithFields.collectionName;

    // ** PATCH MINE ** //
    const existentItem = await fetchSingleItem({ collectionName, id });

    if (existentItem.userId !== userId) {
      throw new Error('Invalid user id (' + existentItem.userId + '!==' + userId + ')');
    }

    const dbItemData = await updateEntity({
      id,
      body,
      auditUid,
      organizationId,
      entitySchemaWithFields,
    });

    return res.status(204).send(dbItemData);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.patchByUser = async function (req, res) {
  try {
    console.log('Patch by user entered');

    const { userId: auditUid, organizationId } = res.locals;
    const { schemaName, schemaId, id, userId } = req.params; // pathologies
    const body = req.body;

    if (!id) throw new CustomError.TechnicalError('ERROR_MISSING_ARGS', null, 'Invalid args', null);

    const entitySchemaWithFields = await fetchSchemaWithFields(
      res,
      organizationId,
      schemaName,
      schemaId
    );

    const collectionName = entitySchemaWithFields.collectionName;

    // ** PATCH BY USER ** //
    const existentItem = await fetchSingleItem({ collectionName, id });

    if (existentItem.userId !== userId) {
      throw new Error('Invalid user id');
    }

    const dbItemData = await updateEntity({
      id,
      body,
      auditUid,
      organizationId,
      entitySchemaWithFields,
    });

    return res.status(204).send(dbItemData);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.patchByCompany = async function (req, res) {
  try {
    console.log('Patch by company entered');

    const { userId: auditUid, organizationId } = res.locals;
    const { schemaName, schemaId, id, companyId } = req.params; // pathologies
    const body = req.body;

    if (!id) throw new CustomError.TechnicalError('ERROR_MISSING_ARGS', null, 'Invalid args', null);

    const entitySchemaWithFields = await fetchSchemaWithFields(
      res,
      organizationId,
      schemaName,
      schemaId
    );

    const collectionName = entitySchemaWithFields.collectionName;

    // ** PATCH BY COMPANY ** //
    const existentItem = await fetchSingleItem({ collectionName, id });

    if (existentItem.companyId !== companyId) {
      throw new Error('Invalid user id');
    }

    const dbItemData = await updateEntity({
      id,
      body,
      auditUid,
      organizationId,
      entitySchemaWithFields,
    });

    return res.status(204).send(dbItemData);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

// ** </PATCH> **

// ** <RESTORE> **
exports.restore = async function (req, res) {
  let collectionName = null;
  let auditUid = null;

  try {
    console.log('Patch entered');

    const { userId, organizationId } = res.locals;
    const { schemaName, schemaId, id } = req.params; // pathologies
    auditUid = userId;

    if (!id) throw new CustomError.TechnicalError('ERROR_MISSING_ARGS', null, 'Invalid args', null);

    const entitySchemaWithFields = await fetchSchemaWithFields(
      res,
      organizationId,
      schemaName,
      schemaId
    );

    collectionName = entitySchemaWithFields.collectionName;

    const updateArgs: IUpdateArgs = {
      collectionName,
      id,
      itemData: { state: StateTypes.STATE_ACTIVE },
      auditUid,
    };

    console.log('Restore (' + collectionName + '):' + id);

    const dbItemData = await updateSingleItem(updateArgs);

    console.log('Patch data: (' + collectionName + ')', dbItemData);

    return res.status(204).send(dbItemData);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.restoreMine = async function (req, res) {
  let collectionName = null;
  let auditUid = null;

  try {
    console.log('Restore mine entered');

    const { userId, organizationId } = res.locals;
    const { schemaName, schemaId, id } = req.params; // pathologies
    auditUid = userId;

    if (!id) throw new CustomError.TechnicalError('ERROR_MISSING_ARGS', null, 'Invalid args', null);

    const entitySchemaWithFields = await fetchSchemaWithFields(
      res,
      organizationId,
      schemaName,
      schemaId
    );

    collectionName = entitySchemaWithFields.collectionName;

    // ** PATCH MINE ** //
    const existentItem = await fetchSingleItem({ collectionName, id });

    if (existentItem.userId !== userId) {
      throw new Error('Invalid user id');
    }

    const updateArgs = {
      collectionName,
      id,
      itemData: { state: StateTypes.STATE_ACTIVE },
      auditUid,
    };

    console.log('Restore (' + collectionName + '):' + id);

    const dbItemData = await updateSingleItem(updateArgs);

    console.log('Restore (' + collectionName + ')');

    return res.status(204).send(dbItemData);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.restoreByUser = async function (req, res) {
  let collectionName = null;

  try {
    console.log('Restore by user entered');

    const { userId: auditUid, organizationId } = res.locals;
    const { schemaName, schemaId, id, userId } = req.params; // pathologies

    if (!id) throw new CustomError.TechnicalError('ERROR_MISSING_ARGS', null, 'Invalid args', null);

    const entitySchemaWithFields = await fetchSchemaWithFields(
      res,
      organizationId,
      schemaName,
      schemaId
    );

    collectionName = entitySchemaWithFields.collectionName;

    // ** PATCH MINE ** //
    const existentItem = await fetchSingleItem({ collectionName, id });

    if (existentItem.userId !== userId) {
      throw new Error('Invalid user id');
    }

    const updateArgs = {
      collectionName,
      id,
      itemData: { state: StateTypes.STATE_ACTIVE },
      auditUid,
    };

    console.log('Restore (' + collectionName + '):' + id);

    const dbItemData = await updateSingleItem(updateArgs);

    console.log('Restore: (' + collectionName + ')');

    return res.status(204).send(dbItemData);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.restoreByCompany = async function (req, res) {
  let collectionName = null;

  try {
    console.log('Patch by company entered');

    const { userId: auditUid, organizationId } = res.locals;
    const { schemaName, schemaId, id, companyId } = req.params; // pathologies

    if (!id) throw new CustomError.TechnicalError('ERROR_MISSING_ARGS', null, 'Invalid args', null);

    const entitySchemaWithFields = await fetchSchemaWithFields(
      res,
      organizationId,
      schemaName,
      schemaId
    );

    collectionName = entitySchemaWithFields.collectionName;

    // ** PATCH MINE ** //
    const existentItem = await fetchSingleItem({ collectionName, id });

    if (existentItem.companyId !== companyId) {
      throw new Error('Invalid user id');
    }

    const updateArgs = {
      collectionName,
      id,
      itemData: { state: StateTypes.STATE_ACTIVE },
      auditUid,
    };

    console.log('Restore (' + collectionName + '):' + id);

    const dbItemData = await updateSingleItem(updateArgs);

    console.log('Restore: (' + collectionName + ')');

    return res.status(204).send(dbItemData);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};
// ** </RESTORE> **

// ** <REMOVE> **
const removeCore = async (entitySchemaWithFields, collectionName, id, auditUid) => {
  console.log(`Element to remove ${id} from ${collectionName}`);

  if (
    entitySchemaWithFields.schemaType === EntitySchemaTypes.SELECT_OPTIONS_ENTITY ||
    entitySchemaWithFields.schemaType === EntitySchemaTypes.ONE_TO_MANY_ENTITY ||
    entitySchemaWithFields.schemaType === EntitySchemaTypes.RELATIONSHIP_ENTITY ||
    entitySchemaWithFields.schemaType === EntitySchemaTypes.RELATIONSHIP_USER2USER_ENTITY
  ) {
    console.log('Remove phisical');
    await deleteSingleItem({ collectionName, id });
  } else {
    console.log('Remove logical');
    await deleteLogicalSingleItem({
      id,
      collectionName,
      auditUid,
    });
  }

  console.log('Removed successfull');
};

exports.remove = async function (req, res) {
  try {
    console.log('Remove entered');

    const { organizationId, userId: auditUid } = res.locals;
    const { schemaName, schemaId, id } = req.params; // pathologies

    if (!id) throw new CustomError.TechnicalError('ERROR_MISSING_ARGS', null, 'Invalid args', null);

    const entitySchemaWithFields = await fetchSchemaWithFields(
      res,
      organizationId,
      schemaName,
      schemaId
    );

    const collectionName = entitySchemaWithFields.collectionName;

    await removeCore(entitySchemaWithFields, collectionName, id, auditUid);

    return res.status(204).send({});
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.removeMine = async function (req, res) {
  try {
    console.log('Remove mine entered');

    const { userId, organizationId, userId: auditUid } = res.locals;
    const { schemaName, schemaId, id } = req.params; // pathologies

    if (!id) throw new CustomError.TechnicalError('ERROR_MISSING_ARGS', null, 'Invalid args', null);

    const entitySchemaWithFields = await fetchSchemaWithFields(
      res,
      organizationId,
      schemaName,
      schemaId
    );

    const collectionName = entitySchemaWithFields.collectionName;

    // ** REMOVE MINE ** //
    const existentItem = await fetchSingleItem({ collectionName, id });

    if (existentItem.userId !== userId) {
      throw new Error('Invalid user id');
    }

    await removeCore(entitySchemaWithFields, collectionName, id, auditUid);

    return res.status(204).send({});
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.removeByUser = async function (req, res) {
  let collectionName = null;

  try {
    console.log('Remove by yser entered');

    const { organizationId, userId: auditUid } = res.locals;
    const { schemaName, schemaId, id, userId } = req.params; // pathologies

    if (!id) throw new CustomError.TechnicalError('ERROR_MISSING_ARGS', null, 'Invalid args', null);

    const entitySchemaWithFields = await fetchSchemaWithFields(
      res,
      organizationId,
      schemaName,
      schemaId
    );

    collectionName = entitySchemaWithFields.collectionName;

    // ** REMOVE BY USER ** //
    const existentItem = await fetchSingleItem({ collectionName, id });

    if (existentItem.userId !== userId) {
      throw new Error('Invalid user id');
    }

    await removeCore(entitySchemaWithFields, collectionName, id, auditUid);

    return res.status(204).send({});
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.removeByCompany = async function (req, res) {
  try {
    console.log('Remove by company entered');

    const { organizationId, userId: auditUid } = res.locals;
    const { schemaName, schemaId, id, companyId } = req.params; // pathologies

    if (!id) throw new CustomError.TechnicalError('ERROR_MISSING_ARGS', null, 'Invalid args', null);

    const entitySchemaWithFields = await fetchSchemaWithFields(
      res,
      organizationId,
      schemaName,
      schemaId
    );

    const collectionName = entitySchemaWithFields.collectionName;

    // ** REMOVE BY COMPANY ** //
    const existentItem = await fetchSingleItem({ collectionName, id });

    if (existentItem.companyId !== companyId) {
      throw new Error('Invalid user id');
    }

    await removeCore(entitySchemaWithFields, collectionName, id, auditUid);

    return res.status(204).send({});
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

// ** </REMOVE> **

// ** <CREATE> **

exports.create = async function (req, res) {
  try {
    console.log('Create entered');

    const { userId: auditUid, organizationId } = res.locals;
    const { schemaName, schemaId } = req.params; // pathologies
    const body = req.body;

    const entitySchemaWithFields = await fetchSchemaWithFields(
      res,
      organizationId,
      schemaName,
      schemaId
    );

    const dbItemData = await createEntity({
      body,
      auditUid,
      organizationId,
      entitySchemaWithFields,
    });

    return res.status(201).send(dbItemData);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.createMine = async function (req, res) {
  try {
    console.log('Create mine entered');

    const { userId, organizationId } = res.locals;
    const { schemaName, schemaId } = req.params; // pathologies
    const auditUid = userId;

    const body = req.body;
    body.userId = userId;

    const entitySchemaWithFields = await fetchSchemaWithFields(
      res,
      organizationId,
      schemaName,
      schemaId
    );

    const dbItemData = await createEntity({
      body,
      auditUid,
      organizationId,
      entitySchemaWithFields,
    });

    return res.status(201).send(dbItemData);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.createByUser = async function (req, res) {
  try {
    console.log('createByUser entered');

    const { userId: auditUid, organizationId } = res.locals;
    const { schemaName, schemaId, userId } = req.params; // pathologies

    const body = req.body;
    // ** BY USER **
    body.userId = userId;

    const entitySchemaWithFields = await fetchSchemaWithFields(
      res,
      organizationId,
      schemaName,
      schemaId
    );

    const dbItemData = await createEntity({
      body,
      auditUid,
      organizationId,
      entitySchemaWithFields,
    });

    return res.status(201).send(dbItemData);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.createByCompany = async function (req, res) {
  try {
    console.log('createByCompany entered');

    const { userId: auditUid, organizationId } = res.locals;
    const { schemaName, schemaId, companyId } = req.params; // pathologies

    if (!companyId) throw new Error('Missing companyId');

    const body = req.body;

    // ** BY COMPANY **
    body.companyId = companyId;

    const entitySchemaWithFields = await fetchSchemaWithFields(
      res,
      organizationId,
      schemaName,
      schemaId
    );

    const dbItemData = await createEntity({
      body,
      auditUid,
      organizationId,
      entitySchemaWithFields,
    });

    return res.status(201).send(dbItemData);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

// ** </CREATE> **

// ** Schemas primitives

exports.findSchemas = async function (req, res) {
  try {
    const { organizationId } = res.locals;

    // res.startTime('db', 'File DB metric');
    const schemas = await listByPropInner({
      limit: 1000,
      offset: 0,
      filters: null,

      primaryEntityPropName: 'organizationId',
      primaryEntityValue: organizationId,

      listByCollectionName: Collections.SCHEMAS,
      indexedFilters: ['organizationId', 'state'],
      relationships: [
        { collectionName: Collections.SCHEMAS, propertyName: 'relationshipSchemaId' },
      ],
    });

    // res.endime('db');

    if (organizationId) {
      const usersSchema = buildUserSchemaWithFields(organizationId);
      delete usersSchema.fields;

      // const companiesSchema = buildCompanySchemaWithFields(organizationId);
      // delete companiesSchema.fields;

      // const companyEmployeesSchema = buildCompanyEmployeesSchemaWithFields(organizationId);
      // delete companyEmployeesSchema.fields;

      schemas.items.push(usersSchema);
      // schemas.items.push(companiesSchema);
      // schemas.items.push(companyEmployeesSchema);

      schemas.total = schemas.items.length;
    }

    return res.send(schemas);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.getSchemaById = async function (req, res) {
  try {
    const { id } = req.params;
    const { organizationId } = res.locals;

    console.log('Entro (' + id + ')!!');

    const item = await fetchSchemaWithFields(res, organizationId, null, id);

    return res.send(item);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.getSchemaByName = async function (req, res) {
  try {
    const { schemaName } = req.params;
    const { organizationId } = res.locals;

    console.log('Entro (' + schemaName + ')!!');

    const item = await fetchSchemaWithFields(res, organizationId, schemaName);

    return res.send(item);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.patchSchema = async function (req, res) {
  try {
    const { id: schemaId } = req.params;
    const { organizationId, userId: auditUid } = res.locals;

    const organizationSchemas = await fetchOrganizationSchemas({
      organizationId,
    });

    const body = req.body;

    const itemData = await sanitizeData({
      data: body,
      validationSchema: cmsValidationSchemas.update,
    });

    if (
      organizationSchemas.find((item) => {
        return item.name === body.name && item.id !== schemaId;
      })
    ) {
      throw new Error('Duplicated name');
    }

    const result = await updateSingleItem({
      collectionName: Collections.SCHEMAS,
      id: schemaId,
      auditUid,
      itemData,
    });

    return res.status(200).send(result);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.createSchema = async function (req, res) {
  try {
    const { organizationId, userId: auditUid } = res.locals;

    const organizationSchemas = await fetchOrganizationSchemas({
      organizationId,
    });

    const newCollectionName = organizationId + '_' + req.body.name;

    const body = { ...req.body, organizationId, collectionName: newCollectionName };

    const itemData = await sanitizeData({
      data: body,
      validationSchema: cmsValidationSchemas.create,
    });

    if (
      organizationSchemas.find((item) => {
        return item.name === body.name || item.collectionName === body.collectionName;
      })
    ) {
      throw new Error('Duplicated name or collectionName');
    }

    const result = await createFirestoreDocument({
      collectionName: Collections.SCHEMAS,

      auditUid,
      itemData,
    });

    return res.status(201).send(result);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.removeSchema = async function (req, res) {
  try {
    const { id: schemaId } = req.params;

    const { organizationId } = res.locals;

    const schemaWithFields = await fetchSchemaWithFields(res, organizationId, null, schemaId);

    if (schemaWithFields.fields.length) {
      const db = admin.firestore();
      const batch = db.batch();

      schemaWithFields.fields.forEach((field) => {
        console.log(`Remove field (${field.id}) ${field.name}`);

        const ref = db.collection(Collections.SCHEMA_FIELDS).doc(field.id);
        batch.delete(ref);
      });

      await batch.commit();
    }

    console.log(`Remove schema (${schemaWithFields.id}) ${schemaWithFields.name}`);

    const result = await deleteSingleItem({
      collectionName: Collections.SCHEMAS,
      id: schemaId,
    });

    return res.status(200).send(result);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

// ** Schema Fields

exports.findSchemaFieldGroups = async function (req, res) {
  try {
    const { id: schemaId } = req.params;

    const response = await fetchSchemaFieldGroups(schemaId);

    return res.send(response);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.createSchemaFieldGroup = async function (req, res) {
  try {
    const { id: schemaId } = req.params;
    const { organizationId, userId: auditUid } = res.locals;

    const item = await fetchSingleItem({ collectionName: Collections.SCHEMAS, id: schemaId });

    if (item.organizationId !== organizationId) throw new Error('Invalid org id');

    const body = { ...req.body, schemaId, organizationId };

    const itemData = await sanitizeData({
      data: body,
      validationSchema: cmsValidationSchemas.createFieldGroup,
    });

    const result = await createFirestoreDocument({
      collectionName: Collections.SCHEMA_FIELD_GROUPS,

      auditUid,
      itemData,
    });

    return res.send(result);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.patchSchemaFieldGroup = async function (req, res) {
  try {
    const { id: schemaId, fieldGroupId } = req.params;
    const { organizationId, userId: auditUid } = res.locals;

    const item = await fetchSingleItem({ collectionName: Collections.SCHEMAS, id: schemaId });

    if (item.organizationId !== organizationId) throw new Error('Invalid org id');

    const body = { ...req.body };

    console.log('!!!body: ', body);
    const itemData = await sanitizeData({
      data: body,
      validationSchema: cmsValidationSchemas.updateFieldGroup,
    });

    console.log('!!!ItemData: ', itemData);
    const result = await updateSingleItem({
      id: fieldGroupId,
      collectionName: Collections.SCHEMA_FIELD_GROUPS,

      auditUid,
      itemData,
    });

    return res.send(result);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.removeSchemaFieldGroup = async function (req, res) {
  try {
    const { id: schemaId, fieldGroupId } = req.params;
    const { organizationId } = res.locals;

    const schema = await fetchSingleItem({ collectionName: Collections.SCHEMAS, id: schemaId });

    if (schema.organizationId !== organizationId) throw new Error('Invalid org id');

    const field = await fetchSingleItem({
      collectionName: Collections.SCHEMA_FIELD_GROUPS,
      id: fieldGroupId,
    });

    if (field.schemaId !== schemaId) throw new Error('Invalid args, schemaId missmatch');

    const result = await deleteSingleItem({
      collectionName: Collections.SCHEMA_FIELD_GROUPS,
      id: fieldGroupId,
    });

    return res.send(result);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

// ** Schema Fields
exports.findAllSchemasFields = async function (req, res) {
  try {
    const { organizationId } = res.locals;

    console.log('Email sended');

    // 1. fetch all Schemas
    const schemas = await listByPropInner({
      limit: 1000,
      offset: 0,
      filters: null,

      primaryEntityPropName: 'organizationId',
      primaryEntityValue: organizationId,

      listByCollectionName: Collections.SCHEMAS,
      indexedFilters: ['organizationId', 'state'],
    });

    // 2. listo todos los fields
    const schemasFields = (await listByPropInner({
      limit: 1000,
      offset: 0,
      filters: null,

      primaryEntityPropName: 'organizationId',
      primaryEntityValue: organizationId,

      listByCollectionName: Collections.SCHEMA_FIELDS,
      indexedFilters: ['organizationId'],
    })) as { items: IEntitySchemaField[] };

    // 3. obtengo el schema de tipo user
    const userSchemaWithFields = buildUserSchemaWithFields(organizationId);

    userSchemaWithFields.fields.forEach((field) => {
      schemasFields.items.push(field);
    });

    // const companySchemaWithFields = buildCompanySchemaWithFields(organizationId);

    // companySchemaWithFields.fields.forEach((field) => {
    //   schemasFields.items.push(field);
    // });

    // const companyEmployeesSchemaWithFields = buildCompanyEmployeesSchemaWithFields(organizationId);

    // companyEmployeesSchemaWithFields.fields.forEach((field) => {
    //   schemasFields.items.push(field);
    // });

    // 4. agrego a los schemas que son de tipo USER_ENTITY o COMPANY_EMPLOYEES_ENTITY los fields del user
    schemas.items.forEach((schema: IEntitySchema) => {
      if (
        schema.schemaType === EntitySchemaTypes.USER_ENTITY ||
        schema.schemaType === EntitySchemaTypes.COMPANY_EMPLOYEES_ENTITY
      ) {
        userSchemaWithFields.fields.forEach((field) => {
          schemasFields.items.push({ ...field, schemaId: schema.id });
        });
      }
    });

    return res.send(schemasFields);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.findSchemaFields = async function (req, res) {
  try {
    const { id: schemaId } = req.params;
    const { organizationId } = res.locals;

    const schemaWithFields = await fetchSchemaWithFields(res, organizationId, null, schemaId);

    return res.send({
      items: schemaWithFields.fields,
      total: schemaWithFields.fields.length,
      hasMore: false,
    });
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.createSchemaField = async function (req, res) {
  try {
    const { id: schemaId } = req.params;
    const { organizationId, userId: auditUid } = res.locals;

    const entitySchemaWithFields = await fetchSchemaWithFields(
      res,
      organizationId,
      null,
      // schemaName: schemaName,
      schemaId
    );

    const body = { ...req.body, schemaId, organizationId };

    if (
      entitySchemaWithFields.fields.find((item) => {
        return item.name === body.name;
      })
    ) {
      throw new Error('Duplicated field name: ' + entitySchemaWithFields.name + ' > ' + body.name);
    }

    const itemData = await sanitizeData({
      data: body,
      validationSchema: cmsValidationSchemas.createField,
    });

    const result = await createFirestoreDocument({
      collectionName: Collections.SCHEMA_FIELDS,

      auditUid,
      itemData,
    });

    return res.send(result);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.patchSchemaField = async function (req, res) {
  try {
    const { id: schemaId, fieldId } = req.params;
    const { organizationId, userId: auditUid } = res.locals;

    const item = await fetchSingleItem({ collectionName: Collections.SCHEMAS, id: schemaId });

    if (item.organizationId !== organizationId) throw new Error('Invalid org id');

    const body = { ...req.body };

    console.log('!!!body: ', body);
    const itemData = await sanitizeData({
      data: body,
      validationSchema: cmsValidationSchemas.updateField,
    });

    console.log('!!!ItemData: ', itemData);
    const result = await updateSingleItem({
      id: fieldId,
      collectionName: Collections.SCHEMA_FIELDS,

      auditUid,
      itemData,
    });

    return res.send(result);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.removeSchemaField = async function (req, res) {
  try {
    const { id: schemaId, fieldId } = req.params;
    const { organizationId } = res.locals;

    const schema = await fetchSingleItem({ collectionName: Collections.SCHEMAS, id: schemaId });

    if (schema.organizationId !== organizationId) throw new Error('Invalid org id');

    const field = await fetchSingleItem({ collectionName: Collections.SCHEMA_FIELDS, id: fieldId });

    if (field.schemaId !== schemaId) throw new Error('Invalid args, schemaId missmatch');

    const result = await deleteSingleItem({
      collectionName: Collections.SCHEMA_FIELDS,
      id: fieldId,
    });

    return res.send(result);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

// ** Organization User Defined Rols
exports.findOrganizationUserDefinedRols = async function (req, res) {
  try {
    const { organizationId } = res.locals;

    const orgUserDefinedRols = await fetchOrganizationRols({ organizationId });

    return res.send({
      items: orgUserDefinedRols,
      total: orgUserDefinedRols.length,
      hasMore: false,
    });
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.createOrganizationUserDefinedRol = async function (req, res) {
  try {
    const { organizationId, userId: auditUid } = res.locals;

    const orgUserDefinedRols = await fetchOrganizationRols({
      organizationId,
    });

    let { filters } = req.query;

    if (!filters) filters = {};
    if (!filters.state) filters.state = { $equal: Types.StateTypes.STATE_ACTIVE };

    const body = { ...req.body, organizationId };

    if (
      orgUserDefinedRols.find((item) => {
        return item.name === body.name;
      })
    ) {
      throw new Error('Duplicated org name');
    }

    const itemData = await sanitizeData({
      data: body,
      validationSchema: cmsValidationSchemas.createOrganizationUserDefinedRols,
    });

    const result = await createFirestoreDocument({
      collectionName: Collections.ORGANIZATION_USER_DEFINED_ROLS,

      // Esto lo hago por simplicidad para el troubleshooting para que luego en la claim quede mas claro
      // documentId: organizationId + '_' + itemData.name + '_' + uuidv4(),
      id: itemData.name,
      auditUid,
      itemData,
    });

    return res.send(result);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.patchOrganizationUserDefinedRol = async function (req, res) {
  try {
    const { id: rolId } = req.params;
    const { organizationId, userId: auditUid } = res.locals;

    const orgUserDefinedRols = await fetchOrganizationRols({
      organizationId,
    });

    const body = { ...req.body };

    console.log('orgUserDefinedRols', orgUserDefinedRols, 'rolId:', rolId, 'body:', body);

    if (
      orgUserDefinedRols.find((item) => {
        return item.id !== rolId && item.name === body.name;
      })
    ) {
      throw new Error('Duplicated org name (patch)');
    }

    const itemData = await sanitizeData({
      data: body,
      validationSchema: cmsValidationSchemas.updateOrganizationUserDefinedRols,
    });

    console.log('!!!ItemData: ', itemData);
    const result = await updateSingleItem({
      id: rolId,
      collectionName: Collections.ORGANIZATION_USER_DEFINED_ROLS,

      auditUid,
      itemData,
    });

    return res.send(result);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

// TODO MICHEL - verificar que schemas tenian este rol y borrarlo
// tmb verificar sobre los users y tmb borrarlo
exports.removeOrganizationUserDefinedRol = async function (req, res) {
  try {
    const { id: rolId } = req.params;
    const { organizationId } = res.locals;

    const orgUserDefinedRols = await fetchOrganizationRols({
      organizationId,
    });

    if (
      !orgUserDefinedRols.find((role) => {
        return role.id === rolId;
      })
    ) {
      throw new Error('Invalid rol id for org ' + organizationId);
    }

    const body = { ...req.body };

    console.log('orgUserDefinedRols', orgUserDefinedRols, 'rolId:', rolId, 'body:', body);

    const result = await deleteSingleItem({
      id: rolId,
      collectionName: Collections.ORGANIZATION_USER_DEFINED_ROLS,
    });

    return res.send(result);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

// ** START USER ROLS

exports.findUserRolsMine = async function (req, res) {
  try {
    const { userId } = res.locals;

    const { limit, offset } = req.query;

    let { filters } = req.query;

    if (!filters) filters = {};
    if (!filters.state) filters.state = { $equal: Types.StateTypes.STATE_ACTIVE };

    // consulto por relaciones
    const result = await listByPropInner({
      limit,
      offset,
      filters,

      primaryEntityPropName: 'userId',
      primaryEntityValue: userId,

      listByCollectionName: Collections.USERS_ROLS,
      indexedFilters: ['userId'],

      relationships: [
        { collectionName: Collections.ORGANIZATION_USER_DEFINED_ROLS, propertyName: 'roleId' },
      ],
    });

    return res.send(result);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.findUserRolsByUser = async function (req, res) {
  try {
    const { userId } = res.params;

    const { limit, offset } = req.query;

    let { filters } = req.query;

    if (!filters) filters = {};
    if (!filters.state) filters.state = { $equal: Types.StateTypes.STATE_ACTIVE };

    // consulto por relaciones
    const result = await listByPropInner({
      limit,
      offset,
      filters,

      primaryEntityPropName: 'userId',
      primaryEntityValue: userId,

      listByCollectionName: Collections.USERS_ROLS,
      indexedFilters: ['userId'],

      relationships: [
        { collectionName: Collections.ORGANIZATION_USER_DEFINED_ROLS, propertyName: 'roleId' },
      ],
    });

    return res.send(result);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.createUserRolsByUser = async function (req, res) {
  try {
    const { userId } = req.params;
    const { organizationId, userId: auditUid } = res.locals;

    if (!req.body.roleId) throw new Error('Missing args');

    const roleId = req.body.roleId;

    const body = { roleId, userId, organizationId };

    const itemData = await sanitizeData({
      data: body,
      validationSchema: cmsValidationSchemas.createUserRols,
    });

    const result = await createFirestoreDocument({
      collectionName: Collections.USERS_ROLS,

      auditUid,
      itemData,
    });

    return res.send(result);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.patchUserRolsByUser = async function (req, res) {
  try {
    const { userId, id } = res.params;
    const { userId: auditUid } = res.locals;

    const item = await fetchSingleItem({ collectionName: Collections.USERS_ROLS, id });

    if (item.userId !== userId) throw new Error('Invalid user id');

    let { filters } = req.query;

    if (!filters) filters = {};
    if (!filters.state) filters.state = { $equal: Types.StateTypes.STATE_ACTIVE };

    const body = { ...req.body };

    console.log('!!!body: ', body);
    const itemData = await sanitizeData({
      data: body,
      validationSchema: cmsValidationSchemas.updateUserRols,
    });

    console.log('!!!ItemData: ', itemData);
    const result = await updateSingleItem({
      id,
      collectionName: Collections.USERS_ROLS,

      auditUid,
      itemData,
    });

    return res.send(result);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.deleteUserRolsByUser = async function (req, res) {
  try {
    const { userId, id } = res.params;

    const item = await fetchSingleItem({ collectionName: Collections.USERS_ROLS, id });

    if (item.userId !== userId) throw new Error('Invalid user id');

    let { filters } = req.query;

    if (!filters) filters = {};
    if (!filters.state) filters.state = { $equal: Types.StateTypes.STATE_ACTIVE };

    const result = await deleteSingleItem({
      id,
      collectionName: Collections.USERS_ROLS,
    });

    return res.send(result);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.bulkUpsertUserRolsByUser = async function (req, res) {
  try {
    const { userId } = req.params;
    const { organizationId, userId: auditUid } = res.locals;

    if (!req.body.bulkRolsIds) throw new Error('Missing args');

    // obtengo los roles existentes
    let { filters } = req.query;

    if (!filters) filters = {};
    if (!filters.state) filters.state = { $equal: Types.StateTypes.STATE_ACTIVE };

    // consulto por relaciones
    const result = await listByPropInner({
      limit: 1000,
      offset: 0,
      filters,

      primaryEntityPropName: 'userId',
      primaryEntityValue: userId,

      listByCollectionName: Collections.USERS_ROLS,
      indexedFilters: ['userId'],
    });

    const db = admin.firestore();
    const deleteBatch = db.batch();

    result.items.forEach((item) => {
      const ref = db.collection(Collections.USERS_ROLS).doc(item.id);
      deleteBatch.delete(ref);
    });

    await deleteBatch.commit();

    const createBatch = db.batch();

    req.body.bulkRolsIds.forEach((item) => {
      const body = {
        roleId: item,
        userId,
        organizationId,
        state: StateTypes.STATE_ACTIVE,
        ...creationStruct(auditUid),
        ...updateStruct(auditUid),
      };

      // TODO no me deja hacer esto
      // const itemData = await sanitizeData({
      //   data: body,
      //   validationSchema: schemas.createUserRols,
      // });

      const ref = db.collection(Collections.USERS_ROLS).doc();
      createBatch.create(ref, body);
    });

    await createBatch.commit();

    return res.send({});
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

const onUserAddressUpsert = async (schema: IEntitySchema, after: any) => {
  if (schema.name !== CMSCollections.USERS_ADDRESSES) return;

  const userAddress = after as IUsersAddress;

  if (!userAddress.isPrimary) return;

  const auditUid = userAddress.updatedBy ? userAddress.updatedBy : 'admin';

  const updateArgs: IUpdateArgs = {
    collectionName: Collections.USERS,
    id: userAddress.userId,
    itemData: { [nameof<IUserBasicData>('dirtyAddress')]: userAddress.address },
    auditUid,
  };

  await updateSingleItem(updateArgs);

  console.log('User primary address updated ' + JSON.stringify(userAddress));
};

// ** END USER ROLS
exports.cmsEntityOnCreate = functions.firestore
  .document('{collectionName}' + '/{docId}')
  .onCreate(async (snapshot, context) => {
    const { collectionName, docId } = context.params;
    const documentPath = `${collectionName}/${docId}`;

    if (collectionName === 'mail') return;

    try {
      const after = snapshot.data() as IEntity;

      console.log('Start cmsEntityOnCreate ' + documentPath);

      if (!after['@schemaId']) {
        console.log('Doc missing schema id ' + documentPath);
        return;
      }

      const schema = (await fetchSingleItem({
        collectionName: Collections.SCHEMAS,
        id: after['@schemaId'],
      })) as IEntitySchema;

      if (!schema) throw new Error('Schema not found (' + after['@schemaId'] + ')');

      // ACA IRIAN LOS HOOKS

      onUserAddressUpsert(schema, after);

      console.log('End cmsEntityOnCreate ' + documentPath);
    } catch (err) {
      console.error('Error cmsEntityOnCreate', documentPath, err);

      return null;
    }
  });

const onApplicantUpdate = async (schema: IEntitySchema, before: any, after: any) => {
  if (schema.name !== CMSCollections.APPLICANTS) return;
  const beforeApplicant = before as IApplicant;
  const afterApplicant = after as IApplicant;

  if (beforeApplicant.applicantStateType === afterApplicant.applicantStateType) return;

  await EmailSender.send({
    to: EMAIL_INBOX_ADMISSION,
    // message: null,
    template: {
      name: 'on-applicant-state-change',
      data: {
        applicantName: afterApplicant.applicantFullname,
        newState: afterApplicant.applicantStateType,
      },
    },
  });
};

exports.cmsEntityOnUpdate = functions.firestore
  .document('{collectionName}' + '/{docId}')
  .onUpdate(async (change, context) => {
    const { collectionName, docId } = context.params;
    const documentPath = `${collectionName}/${docId}`;

    if (collectionName === 'mail') return;

    try {
      const before = change.before.data() as IEntity;
      const after = change.after.data() as IEntity;

      console.log('Start cmsEntityOnUpdate ' + documentPath);

      if (!after['@schemaId']) {
        console.log('Doc missing schema id ' + documentPath);
        return;
      }

      const schema = (await fetchSingleItem({
        collectionName: Collections.SCHEMAS,
        id: after['@schemaId'],
      })) as IEntitySchema;

      if (!schema) throw new Error('Schema not found (' + after['@schemaId'] + ')');

      // ACA IRIAN LOS HOOKS

      onApplicantUpdate(schema, before, after);

      onUserAddressUpsert(schema, after);

      console.log('End cmsEntityOnUpdate ' + documentPath);
    } catch (err) {
      console.error('Error cmsEntityOnUpdate', documentPath, err);

      return null;
    }
  });

exports.geoQueryUserAddressesByRadius = async ({
  organizationId,
  lat,
  lng,
  radiusInM,
}: {
  organizationId: string;
  lat: number;
  lng: number;
  radiusInM: number;
}) => {
  const center = [lat, lng] as Geopoint;

  console.log('center: ', { center, radiusInM });
  // let userType = null;
  // let specialities = null;

  // if (req.query) {
  //   userType = req.query.userType;
  //   specialities = req.query.specialities;
  // }

  const db = admin.firestore();

  const bounds = geohashQueryBounds(center, radiusInM);

  const promises = [];
  for (const bb of bounds) {
    const qq = db
      .collection(`${organizationId}_${CMSCollections.USERS_ADDRESSES}`)
      .orderBy('address.geohash')
      .startAt(bb[0])
      .endAt(bb[1]);

    promises.push(qq.get());
  }

  // Collect all the query results together into a single list
  const snapshots = await Promise.all(promises);
  const matchingDocs = [];

  for (const snap of snapshots) {
    for (const doc of snap.docs) {
      const docLat = doc.get('address.lat');
      const docLng = doc.get('address.lng');

      // We have to filter out a few false positives due to GeoHash
      // accuracy, but most will match
      const distanceInKm = distanceBetween([docLat, docLng], center);
      const distanceInM = distanceInKm * 1000;
      if (distanceInM <= radiusInM) {
        matchingDocs.push({ distanceInKm, doc });
      }
    }
  }

  const items = matchingDocs.map(({ distanceInKm, doc }) => {
    const id = doc.id;
    const data = doc.data();

    if (data.createdAt) data.createdAt = data.createdAt.toDate();
    if (data.updatedAt) data.updatedAt = data.updatedAt.toDate();

    return { ...data, id, distanceInKm };
  });

  return items;
};

exports.geoQueryUserAddresses = async function (req, res) {
  try {
    const { organizationId } = res.locals;
    // radius in mts
    const { lat, lng, radiusInM } = req.params;

    const items = await exports.geoQueryUserAddressesByRadius({
      organizationId,
      lat: parseFloat(lat),
      lng: parseFloat(lng),
      radiusInM: parseFloat(radiusInM),
    });

    items.forEach((item) => {
      item.workerId = item.userId;
    });

    const relationships = [];
    relationships.push({
      collectionName: Collections.USERS,
      propertyName: nameof<IUsersAddress>('userId'),
    });

    // algunos user addresses no se corresponden con un worker, para estos casos la dependency queda vacia
    relationships.push({
      collectionName: organizationId + '_' + CMSCollections.WORKERS,
      propertyName: 'workerId',
    });

    let results = await fillItemsWithRelationships({
      items,
      relationships,
    });

    if (!results) results = [];

    return res.send(results);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};
