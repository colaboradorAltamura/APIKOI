/* eslint-disable no-unused-vars */

// import { Types } from '../../vs-core';
import * as admin from 'firebase-admin';
import * as functions from 'firebase-functions';

import { DEFAULT_ORGANIZATION_ID } from '../../config/appConfig';
import {
  getSourceEntityData,
  nameof,
  processSchemaFieldItem,
  toDateObject,
  valueOrDefaut,
} from '../../helpers/coreHelper';
import {
  ApplicantsStateTypes,
  CMSCollections,
  DailyReportStatusTypes,
  EnliteServices,
  IApplicant,
  IApplicantQuotation,
  IDailyReport,
  IOpenPosition,
  IPatient,
  IPatientHealthInsurance,
  IPatientPaymentCondition,
  IPatientRelative,
  IPatientsSchedule,
  IPatientsSchedulesException,
  IRelative,
  IUsersAddress,
  IWorker,
  OpenPositionStatusTypes,
  PatientsSchedulesExceptionTypes,
  PaymentConditionStateTypes,
  QuotationStatusTypes,
  UserStatusTypes,
} from '../../types/@autogenerated';

import { StateTypes } from '../../types/stateTypes';
import { ErrorHelper } from '../../vs-core-firebase';
import { handleCronError } from '../../vs-core-firebase/helpers/errorHelper';
import { TechnicalError } from '../../vs-core/error';
import { createEntity, fetchSchemaWithFields } from '../cms/helpers';

import {
  AppointmentStatusTypes,
  IAppointment,
  ScheduleItineraryTypes,
} from '../../types/appointments';
import {
  fetchSingleItem,
  listByPropInner,
  listWithRelationships,
} from '../../vs-core-firebase/helpers/firestoreHelper';

const getRelatedDailyReport = (
  dailyReports: IDailyReport[],
  itineraryId: string,
  currentDay: Date,
  startHours: Date
) => {
  return dailyReports.find((dailyReport) => {
    // defino que hay match si:
    if (dailyReport.patientScheduleId !== itineraryId) return false;

    // y es mismo dia que el day
    const dailyReportStartDate = new Date(
      Date.UTC(
        toDateObject(dailyReport.checkIn).getUTCFullYear(),
        toDateObject(dailyReport.checkIn).getUTCMonth(),
        toDateObject(dailyReport.checkIn).getUTCDate()
      )
    );
    const currentDayStartDate = new Date(
      Date.UTC(currentDay.getUTCFullYear(), currentDay.getUTCMonth(), currentDay.getUTCDate())
    );

    if (
      toDateObject(dailyReportStartDate).getTime() !== toDateObject(currentDayStartDate).getTime()
    ) {
      return false;
    }
    // y mismo horario de inicio
    // si esta cancelado es pq es el mismo id de itinerario y tmb la hora de inicio es igual
    const scheduleStartDatetime = new Date(
      2000,
      1,
      1,
      toDateObject(startHours).getUTCHours(),
      toDateObject(startHours).getUTCMinutes()
    );
    const dailyReportStartDatetime = new Date(
      2000,
      1,
      1,
      toDateObject(dailyReport.checkIn).getUTCHours(),
      toDateObject(dailyReport.checkIn).getUTCMinutes()
    );

    const diff = scheduleStartDatetime.getTime() - dailyReportStartDatetime.getTime();

    const diffInMinutes = Math.round(diff / 60000);

    const JOB_CHECK_IN_OUT_TOLERANCE_IN_MINUTES = 60;

    if (diffInMinutes >= JOB_CHECK_IN_OUT_TOLERANCE_IN_MINUTES) return false;

    return true;
  });
};

const addDays = (date: Date, days: number) => {
  date.setDate(date.getDate() + days);
  return date;
};

const getDaysBetween: (from: Date, to: Date) => Date[] = (from: Date, to: Date) => {
  const daysBetween = [];
  let currentDate = from;
  while (currentDate <= to) {
    daysBetween.push(new Date(currentDate));
    currentDate = addDays(currentDate, 1);
  }

  return daysBetween;
};

const getFirstNameOrDefault: (fullName: string) => string = (fullName) => {
  const ret = valueOrDefaut(fullName.split(' ')[0]);

  if (!ret) return '-';
  return ret;
};

const getLastNameOrDefault: (fullName: string) => string = (fullName) => {
  if (!fullName.split(' ').length || fullName.split(' ').length <= 1) return '-';

  const ret = valueOrDefaut(fullName.split(' ')[1]);

  if (!ret) return '-';
  return ret;
};

const fetchApprovedApplicantQuotation = async ({
  organizationId,
  applicantData,
}: {
  organizationId: string;
  applicantData: IApplicant;
}): Promise<IApplicantQuotation | null> => {
  console.log('fetching applicant quotation ' + applicantData.id);

  const db = admin.firestore();

  const applicantQuotationRef = db
    .collection(`${organizationId}_${CMSCollections.APPLICANT_QUOTATIONS}`)
    .where('state', '==', StateTypes.STATE_ACTIVE)
    .where(nameof<IApplicantQuotation>('applicantId'), '==', applicantData.id)
    .where(
      nameof<IApplicantQuotation>('applicantQuotationStatusType'),
      '==',
      QuotationStatusTypes.APPROVED
    );

  const applicantQuotationQuerySnapshot = await applicantQuotationRef.get();

  if (!applicantQuotationQuerySnapshot.docs || !applicantQuotationQuerySnapshot.docs.length) {
    console.error('Missing approved quotation for applicant: ' + applicantData.id);
    return null;
  }

  const applicantQuotation = applicantQuotationQuerySnapshot.docs[0].data() as IApplicantQuotation;

  const applicantQuotationEntitySchemaWithFields = await fetchSchemaWithFields(
    null,
    organizationId,
    CMSCollections.APPLICANT_QUOTATIONS
  );

  processSchemaFieldItem(applicantQuotation, applicantQuotationEntitySchemaWithFields.fields);

  return applicantQuotation;
};

const createPatientFromApplicant = async (organizationId: string, applicantData: IApplicant) => {
  try {
    console.log('fetching schema by name: ' + CMSCollections.PATIENTS);

    const patientsEntitySchemaWithFields = await fetchSchemaWithFields(
      null,
      organizationId,
      CMSCollections.PATIENTS
    );

    // 2.1 crear body de paciente
    const patientBody: IPatient = {
      firstName: getFirstNameOrDefault(applicantData.applicantFullname),
      lastName: getLastNameOrDefault(applicantData.applicantFullname),

      email: valueOrDefaut(applicantData.applicantEmail),
      appUserStatus: UserStatusTypes.USER_STATUS_TYPE_ACTIVE,
      birtdate: valueOrDefaut(applicantData.applicantBirthdate),
      identificationNumber: valueOrDefaut(applicantData.applicantIdentificationNumber),
      identificationType: valueOrDefaut(applicantData.applicantIdentificationType),
      gender: valueOrDefaut(applicantData.applicantGender),
      enliteService: EnliteServices.CARE,
      // diagnostic
      diagnostic: valueOrDefaut(applicantData.diagnostic),
      diagnosisDetails: valueOrDefaut(applicantData.specialNeeds),
      urgencyLevel: valueOrDefaut(applicantData.urgencyLevel),
      urgencyLevelComments: valueOrDefaut(applicantData.comments),
      previousTreatment: valueOrDefaut(applicantData.wasAssistedBefore),
      aggresiveBehaviour: valueOrDefaut(applicantData.aggressiveBehavior),
      suicideAttempt: valueOrDefaut(applicantData.suicidalThoughts),
      manageMoney: valueOrDefaut(applicantData.cashManagement),
      patientReport: valueOrDefaut(applicantData.patientStory),
      // professional team
      treatmentProfName: valueOrDefaut(applicantData.professionalStaffFullname),
      treatmentProfPhone: valueOrDefaut(applicantData.professionalStaffPhoneNumber),
      // required service
      serviceType: valueOrDefaut(applicantData.serviceDispositive),
      schoolName: valueOrDefaut(applicantData.schoolName),
      schoolContact: valueOrDefaut(applicantData.schoolContact),
      // therapeutic profile required
      therapistType: valueOrDefaut(applicantData.therapistType),
      therapistAmount: valueOrDefaut(applicantData.therapistAmount),
      therapistGender: valueOrDefaut(applicantData.therapistGender),
      therapistSex: valueOrDefaut(applicantData.therapistSex),
      therapistProfile: valueOrDefaut(applicantData.therapistProfile),
      therapistDays: valueOrDefaut(applicantData.therapistDays),
      therapistSchedule: valueOrDefaut(applicantData.therapistSchedule),
      therapistWeeklyHours: valueOrDefaut(applicantData.therapistWeeklyHours),
      therapistMonthlyHours: valueOrDefaut(applicantData.therapistMonthlyHours),
      // cobertura seccion
      writOfProtection: valueOrDefaut(applicantData.amparoIndicator),
      disabilityCertificate: valueOrDefaut(applicantData.cudCertificate),
      affiliateNumber: valueOrDefaut(applicantData.insuranceNumber),
    };

    const auditUid = applicantData.updatedBy ? applicantData.updatedBy : 'admin';

    console.log('creating patient with args: ' + JSON.stringify(patientBody));

    const patientData = await createEntity({
      body: patientBody,
      auditUid,
      organizationId,
      entitySchemaWithFields: patientsEntitySchemaWithFields,
    });

    console.log('patient created successfull: ' + patientData.id);

    return patientData.id;
  } catch (e) {
    const message = 'Error creating patient for ' + applicantData.id + ': ' + e.message;

    throw new TechnicalError('ERROR_CREATE_PATIENT', null, message, e);
  }
};

const createRelativeFromApplicant = async (organizationId: string, applicantData: IApplicant) => {
  try {
    // puede no tener relative
    if (!applicantData.relativeEmail) return null;

    console.log('fetching schema by name: ' + CMSCollections.RELATIVES);

    const relativesEntitySchemaWithFields = await fetchSchemaWithFields(
      null,
      organizationId,
      CMSCollections.RELATIVES
    );

    // 2.1 crear body de relative
    const relativeBody: IRelative = {
      firstName: getFirstNameOrDefault(applicantData.relativeFullname),
      lastName: getLastNameOrDefault(applicantData.relativeFullname),

      email: valueOrDefaut(applicantData.relativeEmail),
      appUserStatus: UserStatusTypes.USER_STATUS_TYPE_ACTIVE,
      identificationNumber: valueOrDefaut(applicantData.relativeIdentificationNumber),
      identificationType: valueOrDefaut(applicantData.relativeIdentificationType),
    };

    const auditUid = applicantData.updatedBy ? applicantData.updatedBy : 'admin';

    console.log('creating relative with args: ' + JSON.stringify(relativeBody));

    const relativeData = await createEntity({
      body: relativeBody,
      auditUid,
      organizationId,
      entitySchemaWithFields: relativesEntitySchemaWithFields,
    });

    console.log('relative created successfull: ' + relativeData.id);

    return relativeData.id;
  } catch (e) {
    const message = 'Error creating relative for ' + applicantData.id + ': ' + e.message;

    const err = new TechnicalError('ERROR_CREATE_RELATIVE', null, message, e);

    handleCronError({ message, error: err });
  }
};

const createPatientRelativeRelFromApplicant = async (
  organizationId: string,
  applicantData: IApplicant,
  patientId: string,
  relativeId: string
) => {
  try {
    console.log('fetching schema by name: ' + CMSCollections.PATIENT_RELATIVES);

    const relEntitySchemaWithFields = await fetchSchemaWithFields(
      null,
      organizationId,
      CMSCollections.PATIENT_RELATIVES
    );

    // 2.1 crear body de PATIENT_RELATIVES
    const relBody: IPatientRelative = {
      patientId,
      relativeId,
      relationshipType: valueOrDefaut(applicantData.relationWithApplicant),
    };

    const auditUid = applicantData.updatedBy ? applicantData.updatedBy : 'admin';

    console.log('creating relative relationship with args: ' + JSON.stringify(relBody));

    const relData = await createEntity({
      body: relBody,
      auditUid,
      organizationId,
      entitySchemaWithFields: relEntitySchemaWithFields,
    });

    console.log('relative relationship created successfull: ' + relData.id);

    return relData.id;
  } catch (e) {
    const message = 'Error creating patient relative for ' + applicantData.id + ': ' + e.message;

    const err = new TechnicalError('ERROR_CREATE_PATIENT_RELATIVE', null, message, e);

    handleCronError({ message, error: err });
  }
};

const createPatientHealthInsuranceRelFromApplicant = async (
  organizationId: string,
  applicantData: IApplicant,
  patientId: string,
  applicantQuotation: IApplicantQuotation
) => {
  try {
    if (!applicantQuotation.healthInsuranceId) {
      console.error('Quotation has no healthInsuranceId');
      return;
    }

    console.log('fetching schema by name: ' + CMSCollections.PATIENT_HEALTH_INSURANCES);

    const relEntitySchemaWithFields = await fetchSchemaWithFields(
      null,
      organizationId,
      CMSCollections.PATIENT_HEALTH_INSURANCES
    );

    // 2.1 crear body de PATIENT_HEALTH_INSURANCES
    const relBody: IPatientHealthInsurance = {
      userId: patientId,
      companyId: applicantQuotation.healthInsuranceId,
    };

    const auditUid = applicantData.updatedBy ? applicantData.updatedBy : 'admin';

    console.log('creating PATIENT_HEALTH_INSURANCES with args: ' + JSON.stringify(relBody));

    const relData = await createEntity({
      body: relBody,
      auditUid,
      organizationId,
      entitySchemaWithFields: relEntitySchemaWithFields,
    });

    console.log('PATIENT_HEALTH_INSURANCES relationship created successfull: ' + relData.id);

    return relData.id;
  } catch (e) {
    const message =
      'Error creating patient health insurance for ' + applicantData.id + ': ' + e.message;

    const err = new TechnicalError('ERROR_CREATE_PATIENT_HI', null, message, e);

    handleCronError({ message, error: err });
  }
};

const createPatientPaymentConfitionsRelFromApplicant = async (
  organizationId: string,
  applicantData: IApplicant,
  patientId: string,
  applicantQuotation: IApplicantQuotation
) => {
  try {
    if (!applicantQuotation.healthInsuranceId) {
      console.error('Quotation has no healthInsuranceId');
      return;
    }

    console.log('fetching schema by name: ' + CMSCollections.PATIENT_PAYMENT_CONDITIONS);

    const relEntitySchemaWithFields = await fetchSchemaWithFields(
      null,
      organizationId,
      CMSCollections.PATIENT_PAYMENT_CONDITIONS
    );

    let paymentDate = 0;

    if (applicantQuotation.paymentDate) {
      try {
        paymentDate = parseInt(applicantQuotation.paymentDate as any);
      } catch (e) {}
    }

    // 2.1 crear body de PATIENT_PAYMENT_CONDITIONS
    const relBody: IPatientPaymentCondition = {
      userId: patientId,
      healthInsuranceAgreementId: valueOrDefaut(applicantQuotation.healthInsuranceAgreementId),
      healthInsuranceId: valueOrDefaut(applicantQuotation.healthInsuranceId),
      paymentConditionsState: PaymentConditionStateTypes.ACTIVE,
      collectionPeriod: valueOrDefaut(applicantQuotation.collectionPeriod),
      hourlyRateEnlite: valueOrDefaut(applicantQuotation.hourRateEnlite),
      hourlyRateWorker: valueOrDefaut(applicantQuotation.hourRateWorker),
      monthlyHours: valueOrDefaut(applicantQuotation.monthlyHours),

      paymentDate,
      paymentMode: valueOrDefaut(applicantQuotation.paymentModeType),
      businessType: valueOrDefaut(applicantQuotation.businessType),
      taxCondition: valueOrDefaut(applicantQuotation.taxConditionType),
      validUntil: valueOrDefaut(applicantQuotation.validUntil),
      validFrom: valueOrDefaut(applicantQuotation.validFrom),
    };

    const auditUid = applicantData.updatedBy ? applicantData.updatedBy : 'admin';

    console.log('creating PATIENT_PAYMENT_CONDITIONS with args: ' + JSON.stringify(relBody));

    const relData = await createEntity({
      body: relBody,
      auditUid,
      organizationId,
      entitySchemaWithFields: relEntitySchemaWithFields,
    });

    console.log('PATIENT_HEALTH_INSURANCES relationship created successfull: ' + relData.id);

    return relData.id;
  } catch (e) {
    const message =
      'Error creating patient payment condition for ' + applicantData.id + ': ' + e.message;

    const err = new TechnicalError('ERROR_CREATE_PATIENT_PAYMENT_CONDITION', null, message, e);

    handleCronError({ message, error: err });
  }
};

const createPatientUserAddressFromApplicant = async (
  organizationId: string,
  applicantData: IApplicant,
  patientId: string
) => {
  try {
    if (!applicantData.applicantAddress) {
      console.log('Missing applicant address, returning');
      return;
    }

    console.log('fetching schema by name: ' + CMSCollections.USERS_ADDRESSES);

    const relEntitySchemaWithFields = await fetchSchemaWithFields(
      null,
      organizationId,
      CMSCollections.USERS_ADDRESSES
    );

    // 2.1 crear body de USERS_ADDRESSES
    const relBody: IUsersAddress = {
      userId: patientId,
      isPrimary: true,
      address: applicantData.applicantAddress,
    };

    const auditUid = applicantData.updatedBy ? applicantData.updatedBy : 'admin';

    console.log('creating USERS_ADDRESSES with args: ' + JSON.stringify(relBody));

    const relData = await createEntity({
      body: relBody,
      auditUid,
      organizationId,
      entitySchemaWithFields: relEntitySchemaWithFields,
    });

    console.log('USERS_ADDRESSES created successfull: ' + relData.id);

    return relData.id;
  } catch (e) {
    const message = 'Error creating patient address for ' + applicantData.id + ': ' + e.message;

    const err = new TechnicalError('ERROR_CREATE_PATIENT_ADDRESS', null, message, e);

    handleCronError({ message, error: err });
  }
};

const createPatientOpenPositionFromApplicant = async (
  organizationId: string,
  patientId: string,
  applicantData: IApplicant,
  applicantQuotation: IApplicantQuotation
) => {
  try {
    console.log('fetching schema by name: ' + CMSCollections.OPEN_POSITIONS);

    const openPositionEntitySchemaWithFields = await fetchSchemaWithFields(
      null,
      organizationId,
      CMSCollections.OPEN_POSITIONS
    );

    // 2.1 crear body de OPEN_POSITIONS
    const openPositionBody: IOpenPosition = {
      patient: patientId,
      // daySchedule?: string;

      // workerAttributes?: []
      workerTypes: applicantData.therapistType,
      pathologyType: applicantData.pathologiesTypes ? [applicantData.pathologiesTypes] : [],
      agePreference: applicantData.applicantsAgeRange ? [applicantData.applicantsAgeRange] : [],
      workerAmount: applicantData.therapistAmount,
      workerProfile: applicantData.therapistProfile,
      workerSex: applicantData.therapistSex,
      statusType: OpenPositionStatusTypes.ACTIVE,
      // paymentDate?: Date;
      budget: applicantQuotation ? applicantQuotation.hourRateWorker : 0,
      jobZone: applicantData.applicantAddress.state ? applicantData.applicantAddress.state : '',
      jobAddress: applicantData.applicantAddress,
      jobDescription: 'Candidate for patient ' + applicantData.applicantFullname,
      // relatedCampaign?: string;
      name: applicantData.applicantFullname,
    };

    const auditUid = applicantData.updatedBy ? applicantData.updatedBy : 'admin';

    console.log('creating OPEN_POSITIONS with args: ' + JSON.stringify(openPositionBody));

    const openPositionData = await createEntity({
      body: openPositionBody,
      auditUid,
      organizationId,
      entitySchemaWithFields: openPositionEntitySchemaWithFields,
    });

    console.log('OPEN_POSITIONS created successfull: ' + openPositionData.id);

    return openPositionData.id;
  } catch (e) {
    const message =
      'Error creating patient open position for ' + applicantData.id + ': ' + e.message;

    const err = new TechnicalError('ERROR_CREATE_PATIENT_OPENPOSITION', null, message, e);

    handleCronError({ message, error: err });
  }
};

// Cada vez que sea actualiza un applicant, entonces se evalua el estado
// en caso de ser "CONVERTED" se genera un usuario asociado y un patient asociado
const convertApplicantToPatient = async (organizationId: string, applicantData: IApplicant) => {
  const applicantEntitySchemaWithFields = await fetchSchemaWithFields(
    null,
    organizationId,
    CMSCollections.APPLICANTS
  );
  // convierte los dates
  processSchemaFieldItem(applicantData, applicantEntitySchemaWithFields.fields);

  const patientId = await createPatientFromApplicant(organizationId, applicantData);
  const relativeId = await createRelativeFromApplicant(organizationId, applicantData);
  debugger;

  if (relativeId) {
    await createPatientRelativeRelFromApplicant(
      organizationId,
      applicantData,
      patientId,
      relativeId
    );
  }

  await createPatientUserAddressFromApplicant(organizationId, applicantData, patientId);

  const applicantQuotation = await fetchApprovedApplicantQuotation({
    organizationId,
    applicantData,
  });

  // en caso de existir un quotation se crean otras relaciones
  if (applicantQuotation) {
    console.log('fetched applicantQuotation ' + JSON.stringify(applicantQuotation));

    await createPatientHealthInsuranceRelFromApplicant(
      organizationId,
      applicantData,
      patientId,
      applicantQuotation
    );

    await createPatientPaymentConfitionsRelFromApplicant(
      organizationId,
      applicantData,
      patientId,
      applicantQuotation
    );
  }

  await createPatientOpenPositionFromApplicant(
    organizationId,
    patientId,
    applicantData,
    applicantQuotation
  );
};

exports.allAppointments = async function (req, res) {
  try {
    const { organizationId } = res.locals;
    if (!req.query) throw new Error('missing from / to query string params (1)');

    // from / to = Appointments desde hasta para esta consulta
    const { from, to } = req.query;

    if (!from || !to) throw new Error('missing from / to query string params (2)');

    // 1. Obtengo worker relacionado al userId recibido

    // TODO
    // const fromDate = toDateObject(from);
    // const toDate = toDateObject(to);

    const fromDate = new Date(2023, 9, 10);
    const toDate = new Date(2023, 9, 30);

    if (!fromDate || !toDate) throw new Error('invalid from / to query string params');

    // 2. obtengo itinerario recurrente (patientSchedules)
    const recurrentSchedulesResponse = (await listWithRelationships({
      limit: 1000,
      offset: 0,
      filters: null,

      listByCollectionName: organizationId + '_' + CMSCollections.PATIENTS_SCHEDULES,
      indexedFilters: null,
      relationships: [
        {
          collectionName: organizationId + '_' + CMSCollections.WORKERS,
          propertyName: nameof<IPatientsSchedule>('workerId'),
        },
        {
          collectionName: organizationId + '_' + CMSCollections.PATIENTS,
          propertyName: nameof<IPatientsSchedule>('userId'),
        },
        {
          collectionName: organizationId + '_' + CMSCollections.USERS_ADDRESSES,
          propertyName: nameof<IPatientsSchedule>('userAddressId'),
        },
      ],
      postProcessor: null,
    })) as { items: IPatientsSchedule[] };

    // 3. obtengo los daily reports de fechas - 1 + 1 dia respecto fromDate toDate
    // TODO MICHEL filtrar x fechas
    const dailyReportsResponse = (await listWithRelationships({
      limit: 1000,
      offset: 0,
      filters: null,

      listByCollectionName: organizationId + '_' + CMSCollections.DAILY_REPORTS,
      indexedFilters: null,
      relationships: null,
      postProcessor: null,
    })) as { items: IDailyReport[] };

    // 4. obtengo itinerario eventual (excepciones = PATIENTS_SCHEDULES_EXCEPTIONS)
    // TODO Filtrar x fechas

    const eventualSchedulesResponse = (await listWithRelationships({
      limit: 1000,
      offset: 0,
      filters: null,

      listByCollectionName: organizationId + '_' + CMSCollections.PATIENTS_SCHEDULES_EXCEPTIONS,
      indexedFilters: null,
      relationships: [
        {
          collectionName: organizationId + '_' + CMSCollections.WORKERS,
          propertyName: nameof<IPatientsSchedulesException>('workerId'),
        },
        {
          collectionName: organizationId + '_' + CMSCollections.USERS_ADDRESSES,
          propertyName: nameof<IPatientsSchedulesException>('userAddressId'),
        },
      ],
      postProcessor: null,
    })) as { items: IPatientsSchedulesException[] };

    // me quedo con los cancelados de este worker
    const cancelledSchedules = eventualSchedulesResponse.items.filter((eventualSchedule) => {
      return (
        eventualSchedule.patientsSchedulesExceptionType ===
        PatientsSchedulesExceptionTypes.CANCELLED
      );
    });

    const daysBetween = getDaysBetween(fromDate, toDate);

    const appointments: IAppointment[] = [];

    // genera workerAppointments por cada day of week que esten entre la franja fromDate / toDate
    // evalua los daily reports para entender el appointmentstatus (checked in / out / pending / done)
    daysBetween.forEach((day) => {
      const dayOfWeek = day.getDay(); // 0 = sunday, 1 = monday, ...

      // me quedo con todos los itinerarios recurrentes del dia
      const recurrentItineraries = recurrentSchedulesResponse.items.filter((recurrentItinerary) => {
        return recurrentItinerary.dayOfWeek === dayOfWeek;
      });

      // recurrentItineraries.forEach((item: any) => {
      //   item.startHour = toDateObject(item.startHour);
      //   item.endHour = toDateObject(item.endHour);
      // });

      recurrentItineraries.forEach((itinerary) => {
        itinerary.startHour = toDateObject(itinerary.startHour);
        itinerary.endHour = toDateObject(itinerary.endHour);

        console.log('itinerary:', itinerary);

        const relatedPatient = getSourceEntityData({
          obj: itinerary,
          key: nameof<IPatientsSchedule>('userId'),
        });

        if (!relatedPatient) {
          console.error('Missing related patient (' + itinerary.id + ')');
          return;
        }

        const relatedWorker = getSourceEntityData({
          obj: itinerary,
          key: nameof<IPatientsSchedule>('workerId'),
        }) as IWorker | null;

        const userAddress = getSourceEntityData({
          obj: itinerary,
          key: nameof<IPatientsSchedule>('userAddressId'),
        });

        if (!userAddress) {
          console.error('Missing related user address (' + itinerary.id + ')');
          return;
        }

        // si existe un registro en cancelados entonces lo omito
        const isCancelled = cancelledSchedules.find((cancelledSchedule) => {
          // defino que hay match si:
          // mismo id de itinerario (Los lunes 12.30 hasta 2.30 o los miercoles 9.00 a 18.00)
          if (cancelledSchedule.relatedPatientScheduleId !== itinerary.id) return false;

          // y es mismo dia que el day
          const cancelledEventStartDate = new Date(
            Date.UTC(
              cancelledSchedule.start.getUTCFullYear(),
              cancelledSchedule.start.getUTCMonth(),
              cancelledSchedule.start.getUTCDate()
            )
          );
          const currentDayStartDate = new Date(
            Date.UTC(day.getUTCFullYear(), day.getUTCMonth(), day.getUTCDate())
          );

          if (cancelledEventStartDate.getTime() !== currentDayStartDate.getTime()) return false;
          // y mismo horario de inicio
          // si esta cancelado es pq es el mismo id de itinerario y tmb la hora de inicio es igual
          const scheduleStartDatetime = new Date(
            2000,
            1,
            1,
            itinerary.startHour.getUTCHours(),
            itinerary.startHour.getUTCMinutes()
          );
          const cancelledStartDatetime = new Date(
            2000,
            1,
            1,
            cancelledSchedule.start.getUTCHours(),
            cancelledSchedule.start.getUTCMinutes()
          );

          if (scheduleStartDatetime.getTime() !== cancelledStartDatetime.getTime()) return false;

          return true;
        });

        const relatedDailyReport = getRelatedDailyReport(
          dailyReportsResponse.items,
          itinerary.id,
          day,
          itinerary.startHour
        );

        let appointmentStatus = AppointmentStatusTypes.PENDING;

        if (isCancelled) {
          appointmentStatus = AppointmentStatusTypes.CANCELLED;
        } else if (
          relatedDailyReport &&
          relatedDailyReport.dailyReportStatus === DailyReportStatusTypes.COMPLETED
        ) {
          appointmentStatus = AppointmentStatusTypes.DONE;
        } else if (relatedDailyReport && relatedDailyReport.checkOut) {
          appointmentStatus = AppointmentStatusTypes.CHECKED_OUT;
        } else if (relatedDailyReport && relatedDailyReport.checkIn) {
          appointmentStatus = AppointmentStatusTypes.CHECKED_IN;
        }

        const start = new Date(
          day.getUTCFullYear(),
          day.getUTCMonth(),
          day.getUTCDate(),
          itinerary.startHour.getHours(),
          itinerary.startHour.getMinutes()
        );
        const end = new Date(
          day.getUTCFullYear(),
          day.getUTCMonth(),
          day.getUTCDate(),
          itinerary.endHour.getHours(),
          itinerary.endHour.getMinutes()
        );

        const appointment: IAppointment = {
          start,
          end,
          patient: relatedPatient,
          worker: relatedWorker,
          userAddress,
          appointmentStatus,
          itineraryId: itinerary.id,
          itineraryType: ScheduleItineraryTypes.RECURRENT,
        };

        appointments.push(appointment);
      });
    });

    // 5 obtengo itinerario eventual (excepciones = PATIENTS_SCHEDULES_EXCEPTIONS) filtrando por prop reasignedWorkerId y el estado es scheduleExceptionStatus = reasigned
    // TODO
    // const eventualReasignedSchedulesResponse = (await listByPropInner({
    //   limit: 1000,
    //   offset: 0,
    //   filters: null,

    //   primaryEntityPropName: nameof<IPatientsSchedulesException>('reasignedWorkerId'),
    //   primaryEntityValue: worker.id,

    //   listByCollectionName: organizationId + '_' + CMSCollections.PATIENTS_SCHEDULES_EXCEPTIONS,
    //   indexedFilters: [nameof<IPatientsSchedulesException>('reasignedWorkerId')],
    //   postProcessor: null,
    //   overridePrimaryRelationshipOperator: null,
    //   relationships: [
    //     {
    //       collectionName: organizationId + '_' + CMSCollections.PATIENTS,
    //       propertyName: nameof<IPatientsSchedulesException>('userId'),
    //     },
    //     {
    //       collectionName: organizationId + '_' + CMSCollections.USERS_ADDRESSES,
    //       propertyName: nameof<IPatientsSchedulesException>('userAddressId'),
    //     },
    //   ],
    // })) as { items: IPatientsSchedulesException[] };

    // 3.2.1 sumar estos registros al array de workerAppointments
    // TODO
    // eventualReasignedSchedulesResponse.items.forEach((eventualSchedule) => {
    //   const relatedDailyReport = getRelatedDailyReport(
    //     dailyReportsResponse.items,
    //     eventualSchedule.relatedPatientScheduleId,
    //     eventualSchedule.start,
    //     eventualSchedule.start
    //   );

    //   const relatedPatient = getSourceEntityData({
    //     obj: eventualSchedule,
    //     key: nameof<IPatientsSchedulesException>('userId'),
    //   });

    //   if (!relatedPatient) {
    //     console.error('Missing related patient (2) (' + eventualSchedule.id + ')');
    //     return;
    //   }

    //   const userAddress = getSourceEntityData({
    //     obj: eventualSchedule,
    //     key: nameof<IPatientsSchedulesException>('userAddressId'),
    //   });

    //   if (!userAddress) {
    //     console.error('Missing related user address (2) (' + eventualSchedule.id + ')');
    //     return;
    //   }

    //   let appointmentStatus = WorkerAppointmentStatusTypes.PENDING;

    //   if (relatedDailyReport.dailyReportStatus === DailyReportStatusTypes.COMPLETED) {
    //     appointmentStatus = WorkerAppointmentStatusTypes.DONE;
    //   } else if (relatedDailyReport.checkOut) {
    //     appointmentStatus = WorkerAppointmentStatusTypes.CHECKED_OUT;
    //   } else if (relatedDailyReport.checkIn) {
    //     appointmentStatus = WorkerAppointmentStatusTypes.CHECKED_IN;
    //   }
    //   const appointment: IWorkerAppointment = {
    //     start: eventualSchedule.start,
    //     end: eventualSchedule.end,
    //     patient: relatedPatient,
    //     worker,
    //     userAddress,
    //     appointmentStatus,
    //     itineraryId: eventualSchedule.relatedPatientScheduleId,
    //     itineraryType: WorkerScheduleItineraryTypes.EVENTUAL,
    //   };

    //   appointments.push(appointment);
    // });

    return res.send(appointments);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

const fetchPatientByUserId = async ({
  organizationId,
  userId,
}: {
  organizationId: string;
  userId: string;
}): Promise<IPatient | null> => {
  console.log('fetching worker by id ' + userId);

  const data = (await fetchSingleItem({
    collectionName: `${organizationId}_${CMSCollections.PATIENTS}`,
    id: userId,
  })) as IPatient;

  if (!data) return null;

  const applicantQuotationEntitySchemaWithFields = await fetchSchemaWithFields(
    null,
    organizationId,
    CMSCollections.PATIENTS
  );

  processSchemaFieldItem(data, applicantQuotationEntitySchemaWithFields.fields);

  return data;
};

exports.patientSchedule = async function (req, res) {
  try {
    const { organizationId } = res.locals;
    const { patientId } = req.params;

    if (!req.query) throw new Error('missing from / to query string params (1)');

    // from / to = Appointments desde hasta para esta consulta
    const { from, to } = req.query;

    if (!from || !to) throw new Error('missing from / to query string params (2)');

    // 1. Obtengo patient relacionado al userId recibido
    const patient = await fetchPatientByUserId({ organizationId, userId: patientId });

    if (!patient) throw new Error('Missing patient (' + patientId + ')');

    const fromDate = toDateObject(from);
    const toDate = toDateObject(to);

    if (!fromDate || !toDate) throw new Error('invalid from / to query string params');

    // 2. obtengo itinerario recurrente (patientSchedules)
    const recurrentPatientSchedulesResponse = (await listByPropInner({
      limit: 1000,
      offset: 0,
      filters: null,

      primaryEntityPropName: nameof<IPatientsSchedule>('userId'),
      primaryEntityValue: patient.id,

      listByCollectionName: organizationId + '_' + CMSCollections.PATIENTS_SCHEDULES,
      indexedFilters: [nameof<IPatientsSchedule>('userId')],
      postProcessor: null,
      overridePrimaryRelationshipOperator: null,
      relationships: [
        {
          collectionName: organizationId + '_' + CMSCollections.WORKERS,
          propertyName: nameof<IPatientsSchedule>('workerId'),
        },
        {
          collectionName: organizationId + '_' + CMSCollections.USERS_ADDRESSES,
          propertyName: nameof<IPatientsSchedule>('userAddressId'),
        },
      ],
    })) as { items: IPatientsSchedule[] };

    // 3. obtengo daily reports de este patient, TODO MICHEL agregar filtro de fechas - 1 + 1 dia respecto fromDate toDate
    const patientDailyReportsResponse = (await listByPropInner({
      limit: 1000,
      offset: 0,
      filters: null,

      primaryEntityPropName: nameof<IDailyReport>('userId'),
      primaryEntityValue: patient.id,

      listByCollectionName: organizationId + '_' + CMSCollections.DAILY_REPORTS,
      indexedFilters: [nameof<IDailyReport>('userId')],
      postProcessor: null,
      overridePrimaryRelationshipOperator: null,
      relationships: null,
    })) as { items: IDailyReport[] };

    // 4. obtengo itinerario eventual (excepciones = PATIENTS_SCHEDULES_EXCEPTIONS) filtrando por prop userId (patient)
    const eventualPatientSchedulesResponse = (await listByPropInner({
      limit: 1000,
      offset: 0,
      filters: null,

      primaryEntityPropName: nameof<IPatientsSchedulesException>('userId'),
      primaryEntityValue: patient.id,

      listByCollectionName: organizationId + '_' + CMSCollections.PATIENTS_SCHEDULES_EXCEPTIONS,
      indexedFilters: [nameof<IPatientsSchedulesException>('userId')],
      postProcessor: null,
      overridePrimaryRelationshipOperator: null,
      relationships: [
        {
          collectionName: organizationId + '_' + CMSCollections.USERS_ADDRESSES,
          propertyName: nameof<IPatientsSchedulesException>('userAddressId'),
        },
      ],
    })) as { items: IPatientsSchedulesException[] };

    // me quedo con los cancelados de este patient
    const cancelledPatientSchedules = eventualPatientSchedulesResponse.items.filter(
      (eventualSchedule) => {
        return (
          eventualSchedule.patientsSchedulesExceptionType ===
          PatientsSchedulesExceptionTypes.CANCELLED
        );
      }
    );

    const daysBetween = getDaysBetween(fromDate, toDate);

    const patientAppointments: IAppointment[] = [];

    // genera patientAppointments por cada day of week que esten entre la franja fromDate / toDate
    // evalua los daily reports para entender el appointmentstatus (checked in / out / pending / done)
    daysBetween.forEach((day) => {
      const dayOfWeek = day.getDay(); // 0 = sunday, 1 = monday, ...

      // me quedo con todos los itinerarios recurrentes del dia
      const recurrentItineraries = recurrentPatientSchedulesResponse.items.filter(
        (recurrentItinerary) => {
          return recurrentItinerary.dayOfWeek === dayOfWeek;
        }
      );

      recurrentItineraries.forEach((itinerary) => {
        const relatedWorker = getSourceEntityData({
          obj: itinerary,
          key: nameof<IPatientsSchedule>('workerId'),
        });

        if (!relatedWorker) {
          console.error('Missing related patient (' + itinerary.id + ')');
          return;
        }

        const userAddress = getSourceEntityData({
          obj: itinerary,
          key: nameof<IPatientsSchedule>('userAddressId'),
        });

        if (!userAddress) {
          console.error('Missing related user address (' + itinerary.id + ')');
          return;
        }

        // si existe un registro en cancelados entonces lo omito
        const isCancelled = cancelledPatientSchedules.find((cancelledSchedule) => {
          // defino que hay match si:
          // mismo id de itinerario (Los lunes 12.30 hasta 2.30 o los miercoles 9.00 a 18.00)
          if (cancelledSchedule.relatedPatientScheduleId !== itinerary.id) return false;

          // y es mismo dia que el day
          const cancelledEventStartDate = new Date(
            Date.UTC(
              cancelledSchedule.start.getUTCFullYear(),
              cancelledSchedule.start.getUTCMonth(),
              cancelledSchedule.start.getUTCDate()
            )
          );
          const currentDayStartDate = new Date(
            Date.UTC(day.getUTCFullYear(), day.getUTCMonth(), day.getUTCDate())
          );

          if (cancelledEventStartDate.getTime() !== currentDayStartDate.getTime()) return false;
          // y mismo horario de inicio
          // si esta cancelado es pq es el mismo id de itinerario y tmb la hora de inicio es igual
          const scheduleStartDatetime = new Date(
            2000,
            1,
            1,
            itinerary.startHour.getUTCHours(),
            itinerary.startHour.getUTCMinutes()
          );
          const cancelledStartDatetime = new Date(
            2000,
            1,
            1,
            cancelledSchedule.start.getUTCHours(),
            cancelledSchedule.start.getUTCMinutes()
          );

          if (scheduleStartDatetime.getTime() !== cancelledStartDatetime.getTime()) return false;

          return true;
        });

        const relatedDailyReport = getRelatedDailyReport(
          patientDailyReportsResponse.items,
          itinerary.id,
          day,
          itinerary.startHour
        );

        let appointmentStatus = AppointmentStatusTypes.PENDING;

        if (isCancelled) {
          appointmentStatus = AppointmentStatusTypes.CANCELLED;
        } else if (
          relatedDailyReport &&
          relatedDailyReport.dailyReportStatus === DailyReportStatusTypes.COMPLETED
        ) {
          appointmentStatus = AppointmentStatusTypes.DONE;
        } else if (relatedDailyReport && relatedDailyReport.checkOut) {
          appointmentStatus = AppointmentStatusTypes.CHECKED_OUT;
        } else if (relatedDailyReport && relatedDailyReport.checkIn) {
          appointmentStatus = AppointmentStatusTypes.CHECKED_IN;
        }

        const start = new Date(
          day.getUTCFullYear(),
          day.getUTCMonth(),
          day.getUTCDate(),
          itinerary.startHour.getHours(),
          itinerary.startHour.getMinutes()
        );
        const end = new Date(
          day.getUTCFullYear(),
          day.getUTCMonth(),
          day.getUTCDate(),
          itinerary.endHour.getHours(),
          itinerary.endHour.getMinutes()
        );

        const appointment: IAppointment = {
          start,
          end,
          patient,
          worker: relatedWorker,
          userAddress,
          appointmentStatus,
          itineraryId: itinerary.id,
          itineraryType: ScheduleItineraryTypes.RECURRENT,
        };

        patientAppointments.push(appointment);
      });
    });

    return res.send(patientAppointments);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.patientsOnApplicantUpdate = functions.firestore
  .document(`${DEFAULT_ORGANIZATION_ID}_${CMSCollections.APPLICANTS}/{docId}`)
  .onUpdate(async (change, context) => {
    const organizationId = DEFAULT_ORGANIZATION_ID;

    const { docId } = context.params;
    const documentPath = `${organizationId}_${CMSCollections.APPLICANTS}/${docId}`;
    // const docId = snapshot.key;

    const patientsCollectionName = `${organizationId}_${CMSCollections.PATIENTS}`;

    try {
      const before = change.before.data() as IApplicant;
      const after = change.after.data() as IApplicant;

      console.log('patientsOnApplicantUpdate: ' + documentPath);

      if (after.applicantStateType !== ApplicantsStateTypes.CONVERTED) {
        console.log(
          `Applicant state (${after.applicantStateType}) !==  (${ApplicantsStateTypes.CONVERTED}) . Returning.`
        );
        return;
      }

      if (before.applicantStateType === after.applicantStateType) {
        console.log(
          'Applicant state is equal to before: ' + before.applicantStateType + '. Returning.'
        );
        return;
      }

      // busco si existia un paciente previamente generado para este id de applicant
      console.log('fetching existent patient by email: ' + after.applicantEmail);

      const db = admin.firestore();
      const ref = db
        .collection(patientsCollectionName)
        .where('state', '==', StateTypes.STATE_ACTIVE)
        .where(nameof<IPatient>('email'), '==', after.applicantEmail);

      const querySnapshot = await ref.get();

      if (querySnapshot.docs && querySnapshot.docs.length) {
        console.error(
          'Patient alrready exists with email: ' + after.applicantEmail + '. Returning.'
        );
        return;
      }

      console.log('Email is available, proceed with creation');

      await convertApplicantToPatient(organizationId, after);

      // 2.2 validar body con esquema de paciente
    } catch (err) {
      console.error(
        'Error onUpdate document: ' + documentPath + '. ' + err.message,
        JSON.stringify(err)
      );

      handleCronError({ message: 'Error creating patient for ' + documentPath, error: err });
      return null;
    }
  });

exports.convertApplicantToPatient = async function (req, res) {
  try {
    const { applicantId } = req.params;
    const organizationId = DEFAULT_ORGANIZATION_ID;

    if (!applicantId || !organizationId) {
      throw new TechnicalError('ERROR_MISSING_ARGS', null, 'missing applicantId', null);
    }

    const collectionName = `${organizationId}_${CMSCollections.APPLICANTS}`;
    const applicantData = await fetchSingleItem({ collectionName, id: applicantId });

    const result = await convertApplicantToPatient(organizationId, applicantData as IApplicant);

    return res.send(result);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

const processExpiredDailyReports = async () => {
  const organizationId = DEFAULT_ORGANIZATION_ID;
  const now = Date.now();
  const fromDate = new Date(now);
  addDays(fromDate, -1); // siempre el dia anterior
  const toDate = new Date(now);

  console.log(toDate);
  // 2. obtengo itinerario recurrente (patientSchedules)
  const recurrentSchedulesResponse = (await listWithRelationships({
    limit: 1000,
    offset: 0,
    filters: null,

    listByCollectionName: organizationId + '_' + CMSCollections.PATIENTS_SCHEDULES,
    indexedFilters: null,
    relationships: [
      {
        collectionName: organizationId + '_' + CMSCollections.WORKERS,
        propertyName: nameof<IPatientsSchedule>('workerId'),
      },
      {
        collectionName: organizationId + '_' + CMSCollections.PATIENTS,
        propertyName: nameof<IPatientsSchedule>('userId'),
      },
      {
        collectionName: organizationId + '_' + CMSCollections.USERS_ADDRESSES,
        propertyName: nameof<IPatientsSchedule>('userAddressId'),
      },
    ],
    postProcessor: null,
  })) as { items: IPatientsSchedule[] };

  // 3. obtengo los daily reports de fechas - 1 + 1 dia respecto fromDate toDate
  // TODO MICHEL filtrar x fechas
  const dailyReportsResponse = (await listWithRelationships({
    limit: 1000,
    offset: 0,
    filters: null,

    listByCollectionName: organizationId + '_' + CMSCollections.DAILY_REPORTS,
    indexedFilters: null,
    relationships: null,
    postProcessor: null,
  })) as { items: IDailyReport[] };

  // 4. obtengo itinerario eventual (excepciones = PATIENTS_SCHEDULES_EXCEPTIONS)
  // TODO Filtrar x fechas

  const eventualSchedulesResponse = (await listWithRelationships({
    limit: 1000,
    offset: 0,
    filters: null,

    listByCollectionName: organizationId + '_' + CMSCollections.PATIENTS_SCHEDULES_EXCEPTIONS,
    indexedFilters: null,
    relationships: [
      {
        collectionName: organizationId + '_' + CMSCollections.WORKERS,
        propertyName: nameof<IPatientsSchedulesException>('workerId'),
      },
      {
        collectionName: organizationId + '_' + CMSCollections.USERS_ADDRESSES,
        propertyName: nameof<IPatientsSchedulesException>('userAddressId'),
      },
    ],
    postProcessor: null,
  })) as { items: IPatientsSchedulesException[] };

  // me quedo con los cancelados de este worker
  const cancelledSchedules = eventualSchedulesResponse.items.filter((eventualSchedule) => {
    return (
      eventualSchedule.patientsSchedulesExceptionType === PatientsSchedulesExceptionTypes.CANCELLED
    );
  });

  const daysBetween = getDaysBetween(fromDate, toDate);

  const appointments: IAppointment[] = [];

  // genera workerAppointments por cada day of week que esten entre la franja fromDate / toDate
  // evalua los daily reports para entender el appointmentstatus (checked in / out / pending / done)
  daysBetween.forEach((day) => {
    const dayOfWeek = day.getDay(); // 0 = sunday, 1 = monday, ...

    console.log('dayOfWeek:', dayOfWeek);

    // me quedo con todos los itinerarios recurrentes del dia
    const recurrentItineraries = recurrentSchedulesResponse.items.filter((recurrentItinerary) => {
      return recurrentItinerary.dayOfWeek === dayOfWeek;
    });

    // recurrentItineraries.forEach((item: any) => {
    //   item.startHour = toDateObject(item.startHour);
    //   item.endHour = toDateObject(item.endHour);
    // });

    recurrentItineraries.forEach((itinerary) => {
      itinerary.startHour = toDateObject(itinerary.startHour);
      itinerary.endHour = toDateObject(itinerary.endHour);

      console.log('itinerary:', itinerary);

      const relatedPatient = getSourceEntityData({
        obj: itinerary,
        key: nameof<IPatientsSchedule>('userId'),
      });

      if (!relatedPatient) {
        console.error('Missing related patient (' + itinerary.id + ')');
        return;
      }

      const relatedWorker = getSourceEntityData({
        obj: itinerary,
        key: nameof<IPatientsSchedule>('workerId'),
      }) as IWorker | null;

      const userAddress = getSourceEntityData({
        obj: itinerary,
        key: nameof<IPatientsSchedule>('userAddressId'),
      });

      if (!userAddress) {
        console.error('Missing related user address (' + itinerary.id + ')');
        return;
      }

      // si existe un registro en cancelados entonces lo omito
      const isCancelled = cancelledSchedules.find((cancelledSchedule) => {
        // defino que hay match si:
        // mismo id de itinerario (Los lunes 12.30 hasta 2.30 o los miercoles 9.00 a 18.00)
        if (cancelledSchedule.relatedPatientScheduleId !== itinerary.id) return false;

        // y es mismo dia que el day
        const cancelledEventStartDate = new Date(
          Date.UTC(
            cancelledSchedule.start.getUTCFullYear(),
            cancelledSchedule.start.getUTCMonth(),
            cancelledSchedule.start.getUTCDate()
          )
        );
        const currentDayStartDate = new Date(
          Date.UTC(day.getUTCFullYear(), day.getUTCMonth(), day.getUTCDate())
        );

        if (cancelledEventStartDate.getTime() !== currentDayStartDate.getTime()) return false;
        // y mismo horario de inicio
        // si esta cancelado es pq es el mismo id de itinerario y tmb la hora de inicio es igual
        const scheduleStartDatetime = new Date(
          2000,
          1,
          1,
          itinerary.startHour.getUTCHours(),
          itinerary.startHour.getUTCMinutes()
        );
        const cancelledStartDatetime = new Date(
          2000,
          1,
          1,
          cancelledSchedule.start.getUTCHours(),
          cancelledSchedule.start.getUTCMinutes()
        );

        if (scheduleStartDatetime.getTime() !== cancelledStartDatetime.getTime()) return false;

        return true;
      });
      const relatedDailyReport = getRelatedDailyReport(
        dailyReportsResponse.items,
        itinerary.id,
        day,
        itinerary.startHour
      );

      // verifica si no existe el daily report, para no crearlo de vuelta
      if (!relatedDailyReport) {
        let appointmentStatus = AppointmentStatusTypes.PENDING;

        if (isCancelled) {
          appointmentStatus = AppointmentStatusTypes.CANCELLED;
        } else if (
          relatedDailyReport &&
          relatedDailyReport.dailyReportStatus === DailyReportStatusTypes.COMPLETED
        ) {
          appointmentStatus = AppointmentStatusTypes.DONE;
        } else if (relatedDailyReport && relatedDailyReport.checkOut) {
          appointmentStatus = AppointmentStatusTypes.CHECKED_OUT;
        } else if (relatedDailyReport && relatedDailyReport.checkIn) {
          appointmentStatus = AppointmentStatusTypes.CHECKED_IN;
        }

        const start = new Date(
          day.getUTCFullYear(),
          day.getUTCMonth(),
          day.getUTCDate(),
          itinerary.startHour.getHours(),
          itinerary.startHour.getMinutes()
        );
        const end = new Date(
          day.getUTCFullYear(),
          day.getUTCMonth(),
          day.getUTCDate(),
          itinerary.endHour.getHours(),
          itinerary.endHour.getMinutes()
        );

        const appointment: IAppointment = {
          start,
          end,
          patient: relatedPatient,
          worker: relatedWorker,
          userAddress,
          appointmentStatus,
          itineraryId: itinerary.id,
          itineraryType: ScheduleItineraryTypes.RECURRENT,
        };

        appointments.push(appointment);
      }
    });
  });

  const TOLERANCE_EXPIRED_APPOINTMENT_IN_MINUTES = 60 * 24;

  await Promise.all(
    appointments.map(async (appointment) => {
      // solo si tiene un worker asociado
      if (appointment.worker) {
        const appointmentStartTime = appointment.start.getTime();
        const nowTime = new Date(now).getTime();

        // verifca si ya se paso de la hora
        if (nowTime - appointmentStartTime >= TOLERANCE_EXPIRED_APPOINTMENT_IN_MINUTES) {
          // crea el body del daily reporty
          const dailyReportBody: IDailyReport = {
            checkIn: appointment.start,
            checkOut: appointment.start, // check this
            checkInLatitude: 0,
            checkInLongitude: 0,
            globalScore: 0,
            generalNotes: '',
            workerId: appointment.worker.id,
            dailyReportStatus: DailyReportStatusTypes.AUTOGENERATED,
            eventDate: new Date(now),
            userId: appointment.patient.id,
            patientScheduleId: appointment.itineraryId,
          };

          // inserta el dailyreport con estado empty
          console.log('creating daily report');
          await createDailyReport(organizationId, dailyReportBody);

          return;
        }
      }
    })
  );
};
const createDailyReport = async (organizationId: string, dailyReportData: IDailyReport) => {
  try {
    console.log('fetching schema by name: ' + CMSCollections.DAILY_REPORTS);

    const dailyReportsEntitySchemaWithFields = await fetchSchemaWithFields(
      null,
      organizationId,
      CMSCollections.DAILY_REPORTS
    );

    const auditUid = dailyReportData.updatedBy ? dailyReportData.updatedBy : 'admin';

    console.log('creating dailyreport with args: ' + JSON.stringify(dailyReportData));

    const dailyReportCreated = await createEntity({
      body: dailyReportData,
      auditUid,
      organizationId,
      entitySchemaWithFields: dailyReportsEntitySchemaWithFields,
    });

    console.log('daily report created successfull: ' + dailyReportCreated.id);

    return dailyReportCreated.id;
  } catch (e) {
    const message = 'Error creating dailyreport: ' + e.message;

    throw new TechnicalError('ERROR_CREATE_DAILYREPORT', null, message, e);
  }
};

exports.cronExpiredDailyReports = functions
  .runWith({
    memory: '1GB',
    // timeoutSeconds: 540,
  })
  .pubsub.schedule('every 60 minutes')
  .timeZone('America/New_York') // Users can choose timezone - default is America/Los_Angeles
  .onRun(async () => {
    try {
      await processExpiredDailyReports();

      console.log('cronPendingDailyReports finished');
    } catch (err) {
      handleCronError({ message: 'Error on cronPendingDailyReports', error: err });
      return null;
    }
  });

// to test from postman
exports.processExpiredDailyReports = async function (req, res) {
  try {
    await processExpiredDailyReports();
    return res.send('processExpiredDailyReports executeds');
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};
