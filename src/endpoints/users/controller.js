/* eslint-disable no-unused-vars */

import { CMSCollections } from '../../types/@autogenerated';
import { createEntity, fetchSchemaWithFields } from '../cms/helpers';
import { createUser } from './helpers';

import { URL } from 'url';
import { handleCronError } from '../../vs-core-firebase/helpers/errorHelper';
import { OpenPositionAsignmentStatusTypes } from '../../types/@autogenerated';

const { parse: parseQuery } = require('querystring');

const admin = require('firebase-admin');

const { updateStruct } = require('../../vs-core-firebase/audit');
const { ErrorHelper } = require('../../vs-core-firebase');

const { Types } = require('../../vs-core');

const { DEFAULT_ORGANIZATION_ID } = require('../../config/appConfig');

const { CustomError } = require('../../vs-core');

const { Collections } = require('../../types/collectionsTypes');

const schemas = require('./schemas');

const {
  sanitizeData,
  fetchItemsByIds,
  remove,
  listByPropInner,
  fetchItems,
  fetchSingleItem,
  updateSingleItem,
  filterItems,
  getFirebaseUsersByIds,
  getFirebaseUserById,
  getFirebaseUserByEmail,
  deleteLogicalSingleItem,
} = require('../../vs-core-firebase/helpers/firestoreHelper');

const { UserRolesHelper } = require('../../helpers/userRolesHelper');
const { buildCompanySchemaWithFields } = require('../../vs-core/helpers/schemas');

const COLLECTION_NAME = Collections.USERS;

const INDEXED_FILTERS = ['state'];

// Solo se usa desde Staff controller
exports.fetchAndUpdateUserAppRols = async ({ auditUid, userId, appRols }) => {
  // 1. obtengo el usuario asociado al empleado
  const targetUser = await getFirebaseUserById(userId);

  console.log('OK fetching user ' + userId, 'user appRols: ' + JSON.stringify(targetUser.appRols));

  // 4. atualizo el usuario
  await updateSingleItem({
    collectionName: Collections.USERS,
    auditUid,
    id: userId,
    itemData: { appRols },
  });

  console.log('ok updating user document');

  // 5. actualizo los claims del usuario en el motor de autenticacion
  await UserRolesHelper.setUserClaims({
    userId,
    appRols,
    enterpriseRols: targetUser.enterpriseRols,
    appUserStatus: targetUser.appUserStatus,
  });

  console.log('ok updating user claims');
};

const patchUser = async function ({ auditUid, userData, appUserStatus }) {
  console.log('patchUser: ' + JSON.stringify(userData));

  if (userData.firstName && userData.lastName) {
    try {
      await admin.auth().updateUser(userData.id, {
        displayName: userData.firstName + ' ' + userData.lastName,

        // email: userData.email,
      });
    } catch (e) {
      throw new CustomError.TechnicalError('ERROR_PATCH_USER_1', null, e.message, e);
    }
  }

  try {
    // el campo appUserStatus es clave para que el front sepa si el usuario está activo o moroso sin consultar servicios adicionales
    if (userData.appRols) {
      const currentFirebaseUser = await getFirebaseUserById(userData.id);

      console.log(
        'Actualizando roles: ',
        JSON.stringify(userData.appRols),
        JSON.stringify(currentFirebaseUser.appRols)
      );
      // AHORA NO Staff >> ANTES SI Staff
      if (
        !userData.appRols.includes(Types.AppRols.APP_STAFF) &&
        currentFirebaseUser.appRols &&
        currentFirebaseUser.appRols.includes(Types.AppRols.APP_STAFF)
      ) {
        console.log('Se elimina el STAFF dado que se borró su rol previo');

        // elimino el staff de la coleccion de staffs
        await deleteLogicalSingleItem({
          id: userData.id,
          collectionName: Collections.STAFF,
          auditUid,
        });
      }

      // AHORA SI Staff >> ANTES NO Staff
      else if (
        userData.appRols.includes(Types.AppRols.APP_STAFF) &&
        (!currentFirebaseUser.appRols ||
          !currentFirebaseUser.appRols.includes(Types.AppRols.APP_STAFF))
      ) {
        const existentStaff = await fetchSingleItem({
          collectionName: Collections.STAFF,
          id: userData.id,
        });

        // si existia simplemente lo reactivo
        // si no existia lanzo un error para que lo cree desde el modulo de staff
        if (existentStaff) {
          console.log('Se actualiza el STAFF dado que se agrego el rol');

          await updateSingleItem({
            collectionName: Collections.STAFF,
            id: userData.id,
            auditUid,
            itemData: { state: Types.StateTypes.STATE_ACTIVE },
          });
        } else {
          throw new CustomError.TechnicalError(
            'ERROR_PATCH_USER_AS_STAFF',
            null,
            'For new staffs create it from the staff module',
            null
          );
        }
      }

      if (!appUserStatus) {
        appUserStatus = currentFirebaseUser.appUserStatus
          ? currentFirebaseUser.appUserStatus
          : null;
      }
      if (!userData.appRols) {
        userData.appRols = currentFirebaseUser.appRols ? currentFirebaseUser.appRols : null;
      }
      if (!userData.enterpriseRols) {
        userData.enterpriseRols = currentFirebaseUser.enterpriseRols
          ? currentFirebaseUser.enterpriseRols
          : null;
      }

      console.log('Setting claims from patch' + JSON.stringify(userData.appRols));

      await UserRolesHelper.setUserClaims({
        userId: userData.id,
        appRols: userData.appRols,
        enterpriseRols: userData.enterpriseRols,
        appUserStatus,
      });
    }

    userData = {
      ...userData,

      state: Types.StateTypes.STATE_ACTIVE,

      ...updateStruct(auditUid),
    };

    if (appUserStatus) userData.appUserStatus = appUserStatus;

    const db = admin.firestore();

    await db.collection(Collections.USERS).doc(userData.id).update(userData);

    return userData;
  } catch (e) {
    throw new CustomError.TechnicalError('ERROR_PATCH_USER_2', null, e.message, e);
  }
};

exports.find = async function (req, res) {
  try {
    // / movies?filters[movies]=USA&fields[]=id&fields[]=name
    let { limit, offset, filters } = req.query;

    if (limit) limit = parseInt(limit);

    if (!limit) limit = 1000;

    if (limit && limit > 1000) {
      throw new CustomError.TechnicalError(
        'ERROR_ARGS',
        null,
        'Limit must be less or equal 1000',
        null
      );
    }

    console.log('Filters - ' + COLLECTION_NAME + ' - ' + JSON.stringify(filters));
    const items = await fetchItems({
      collectionName: COLLECTION_NAME,
      limit,
      filters,
      indexedFilters: INDEXED_FILTERS,
    });

    items.forEach((item) => {
      if (item.birthDate) item.birthDate = item.birthDate.toDate();
      if (item.lastTouchpoint) item.lastTouchpoint = item.lastTouchpoint.toDate();
    });

    console.log('OK - all - fetch (' + COLLECTION_NAME + '): ' + items.length);

    const filteredItems = filterItems({ items, limit, offset, filters });

    if (filteredItems.items) console.log('OK - all - filter: ' + filteredItems.items.length);

    const firebaseUsers = await getFirebaseUsersByIds(
      filteredItems.items.map((user) => {
        return user.id;
      })
    );

    // TODO MICHEL - Acá hay dos props, appRols y grants que se pisan al item. O sea que siempre devuelve lo que está en firebase
    // estaría bueno analizar si esto está bien o no
    filteredItems.items = filteredItems.items.map((item) => {
      const firebaseUser = firebaseUsers.find((fbUser) => {
        return fbUser.uid === item.id;
      });

      if (firebaseUser) return { ...item, ...firebaseUser };

      return { ...item };
    });

    return res.send(filteredItems);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

const validatePatchUser = async function ({ req, res, validationSchema }) {
  try {
    const { userId } = res.locals;
    const auditUid = userId;

    const { userId: targetUserId } = req.params;

    if (!targetUserId) {
      throw new CustomError.TechnicalError('ERROR_MISSING_ARGS', null, 'Invalid args', null);
    }

    const itemData = await sanitizeData({ data: req.body, validationSchema });

    const appRols = itemData.appRols ? itemData.appRols : null;
    const enterpriseRols = itemData.enterpriseRols ? itemData.enterpriseRols : [];

    itemData.id = targetUserId;

    const updatedUser = await patchUser({
      auditUid,
      userData: itemData,
      appUserStatus: itemData.appUserStatus,
      appRols,
      enterpriseRols,
    });

    console.log('Updated user: ', updatedUser);
    return res.status(200).send(updatedUser);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

// desde aca se pueden editar todos los valores, solo los admins deberian poder
exports.patch = async function (req, res) {
  if (
    !res.locals ||
    !res.locals.appRols ||
    !res.locals.appRols.length ||
    res.locals.appRols.length === 0
  ) {
    throw new CustomError.TechnicalError(
      'ERROR_NO_AUTH',
      null,
      'El request no tiene los permisos del usuario',
      null
    );
  }

  // si es admin le dejo updatear todos los campos, sino solo los permitidos para un staff
  if (res.locals.appRols.includes(Types.AppRols.APP_ADMIN)) {
    console.log('updating as ADMIN');
    await validatePatchUser({ req, res, validationSchema: schemas.update });
    return;
  } else if (res.locals.appRols.includes(Types.AppRols.APP_STAFF)) {
    console.log('updating as STAFF');
    await validatePatchUser({ req, res, validationSchema: schemas.updateByStaff });
    return;
  }

  console.log('updating as CURRENT USER');
  await validatePatchUser({ req, res, validationSchema: schemas.updateCurrentSchema });
  return;
};

// OBSOLETO, NO SE USA
// solo hago un metodo aparte y no juego con el decorador 'allowStaffRelationship' porque no quiero que pueda editar todos los valores
exports.patchByStaff = async function (req, res) {
  await validatePatchUser({ req, res, validationSchema: schemas.updateByStaff });
};

exports.remove = async function (req, res) {
  await remove(req, res, COLLECTION_NAME);
};

exports.create = async function (req, res) {
  try {
    const { userId } = res.locals;
    const auditUid = userId;

    console.log('Create args:', JSON.stringify(req.body));

    const itemData = await sanitizeData({ data: req.body, validationSchema: schemas.create });

    const appUserStatus = itemData.appUserStatus;

    const userData = await createUser({
      auditUid,
      userData: itemData,
      appUserStatus: appUserStatus || null,
    });

    return res.status(201).send(userData);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

const getFirebaseUserByEmailOrNull = async (email) => {
  try {
    const firestoreUser = await admin.auth().getUserByEmail(email);
    return firestoreUser;
  } catch (e) {
    if (e.code === 'auth/user-not-found') return null;
    throw e;
  }
};

const getFirestoreUserByEmail = async (email) => {
  const firestoreUsersByEmail = await fetchItems({
    collectionName: COLLECTION_NAME,
    filters: { email: { $equal: email } },
    indexedFilters: ['email'],
  });

  if (!firestoreUsersByEmail || firestoreUsersByEmail.length === 0) {
    return null;
  }

  if (firestoreUsersByEmail.length !== 1) {
    throw new Error('Se encontro más de un usuario con el mismo mail (' + email + ')');
  }

  const user = firestoreUsersByEmail[0];

  return user;
};

exports.createByUser = async function (req, res) {
  try {
    const { userId } = res.locals;
    const auditUid = userId;

    console.log('Create args:', JSON.stringify(req.body));

    // obtengo los datos del request
    let itemData = await sanitizeData({
      data: req.body,
      validationSchema: schemas.createByUser,
    });

    console.log('Validated request OK');
    // valido que no exista el email ya como usuario
    let existentUser = null;
    try {
      existentUser = await getFirebaseUserByEmail(itemData.email);
    } catch (e) {}

    if (existentUser) {
      throw new CustomError.TechnicalError(
        'ERROR_DUPLICATED_EMAIL',
        null,
        'Ya existía el usuario con email ' + itemData.email,
        null
      );
    }

    itemData.appUserStatus = Types.UserStatusTypes.USER_STATUS_TYPE_ACTIVE;
    itemData.appRols = [];

    console.log('Validation data to main creation schema');

    itemData = await sanitizeData({ data: itemData, validationSchema: schemas.create });

    console.log('Validation main creation schema OK');

    const appUserStatus = itemData.appUserStatus;

    // Creo usuario en firebase y en firestore
    const userData = await createUser({
      auditUid,
      userData: itemData,
      appUserStatus: appUserStatus || null,
    });

    console.log('OK creating user');

    return res.status(200).send(userData);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

const fetchUserFullDataById = async (userId) => {
  if (!userId) {
    throw new CustomError.TechnicalError('ERROR_MISSING_ARGS', null, 'Id not recived', null);
  }

  console.log('Fetching user by id: ' + userId);

  const item = await fetchSingleItem({ collectionName: COLLECTION_NAME, id: userId });

  console.log('Fetched user by id: ' + JSON.stringify(item));

  if (!item) return null;

  if (item.birthDate) item.birthDate = item.birthDate.toDate();
  if (item.lastTouchpoint) item.lastTouchpoint = item.lastTouchpoint.toDate();

  const firebaseUser = await getFirebaseUserById(userId);

  // TODO MICHEL - Acá hay props, ej appRols al firebaseUser. O sea que siempre devuelve lo que está en database

  let user = null;
  if (firebaseUser) {
    user = {
      ...firebaseUser,
      ...item,
    };
  } else user = { ...item };

  console.log('OK - get (' + COLLECTION_NAME + ')' + JSON.stringify(user));

  return user;
};

exports.get = async function (req, res) {
  try {
    const { organizationId } = res.locals;

    const { userId } = req.params;

    const user = await fetchUserFullDataById(userId);

    const orgRols = await UserRolesHelper.fetchUserOrgRols({ organizationId, userId });
    user.orgRols = orgRols.map((role) => {
      return role.roleId;
    });

    const userDefinedRols = await UserRolesHelper.fetchUserRols({ organizationId, userId });
    user.userDefinedRols = userDefinedRols.map((role) => {
      return role.roleId;
    });

    if (!user.appRols) user.appRols = [];

    return res.send(user);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

const processSignIn = async ({ organizationId, userId }) => {
  const user = await fetchUserFullDataById(userId);

  console.log('sign in result:' + JSON.stringify(user));

  if (!user) return null;

  const orgRols = await UserRolesHelper.fetchUserOrgRols({ organizationId, userId });
  user.orgRols = orgRols.map((role) => {
    return role.roleId;
  });

  const userDefinedRols = await UserRolesHelper.fetchUserRols({ organizationId, userId });
  user.userDefinedRols = userDefinedRols.map((role) => {
    return role.roleId;
  });

  const userEnterpriseRols = await UserRolesHelper.fetchUserEnterpriseRols({
    organizationId,
    userId,
  });
  user.userDefinedRols = userDefinedRols.map((role) => {
    return role.roleId;
  });

  const defaultUserEnterpriseRol = userEnterpriseRols.length ? userEnterpriseRols[0] : null;

  if (!user.appRols) user.appRols = [];

  await UserRolesHelper.setUserClaims({
    userId,
    appRols: user.appRols,
    orgRols: user.orgRols,
    userDefinedRols: user.userDefinedRols,

    enterpriseRols: defaultUserEnterpriseRol
      ? [
          {
            companyId: defaultUserEnterpriseRol.companyId,
            rols: [Types.EnterpriseRols.ENTERPRISE_EMPLOYEE],
          },
        ]
      : [],
    appUserStatus: user.appUserStatus,
  });

  return user;
};

exports.signIn = async function (req, res) {
  try {
    const { userId } = res.locals;

    const organizationId = DEFAULT_ORGANIZATION_ID;

    const user = await processSignIn({ organizationId, userId });

    if (!user) return res.send(user);

    return res.send(user);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

const getCampaignByCode = async (organizationId, campaignCode) => {
  const result = await listByPropInner({
    limit: 1,
    offset: 0,
    filters: null,

    primaryEntityPropName: 'code',
    primaryEntityValue: campaignCode,

    listByCollectionName: organizationId + '_' + CMSCollections.CAMPAIGNS,
    indexedFilters: ['code'],
  });

  if (result && result.items && result.items.length) return result.items[0];

  return null;
};

const fetchOpenPositionByCampaignId = async (organizationId, campaignId) => {
  const result = await listByPropInner({
    limit: 1,
    offset: 0,
    filters: null,

    primaryEntityPropName: 'relatedCampaign',
    primaryEntityValue: campaignId,

    listByCollectionName: organizationId + '_' + CMSCollections.OPEN_POSITIONS,
    indexedFilters: ['relatedCampaign'],
  });

  if (result && result.items && result.items.length) return result.items[0];

  return null;
};

const createWorkerOpenPositionRelationship = async (organizationId, openPositionId, workerId) => {
  const relEntitySchemaWithFields = await fetchSchemaWithFields(
    null,
    organizationId,
    CMSCollections.OPEN_POSITION_WORKERS,
    null
  );

  await createEntity({
    body: {
      openPositionId,
      userId: workerId,
      assignmentStatus: OpenPositionAsignmentStatusTypes.INTERESTED,
    },
    auditUid: workerId,
    organizationId,
    entitySchemaWithFields: relEntitySchemaWithFields,
  });
};

exports.signUp = async function (req, res) {
  try {
    const auditUid = 'admin';

    console.log('Create args:' + req.body.email);

    const body = req.body;
    // body.appUserStatus = Types.UserStatusTypes.USER_STATUS_TYPE_ACTIVE;
    // body.appRols = [];

    // const itemData = await sanitizeData({ data: body, validationSchema: schemas.create });

    // valido que aún no exista
    const firestoreUser = await getFirebaseUserByEmailOrNull(body.email);

    if (firestoreUser) {
      throw new CustomError.TechnicalError(
        'ERROR_DUPLICATED_EMAIL',
        null,
        'Ya existía el usuario con email ' + body.email,
        null
      );
    }
    const organizationId = DEFAULT_ORGANIZATION_ID;

    let entitySchemaWithFields;
    if (body.workerState) {
      entitySchemaWithFields = await fetchSchemaWithFields(
        res,
        organizationId,
        CMSCollections.WORKERS,
        null
      );
    } else {
      entitySchemaWithFields = await fetchSchemaWithFields(
        res,
        organizationId,
        CMSCollections.PATIENTS,
        null
      );
    }

    const dbItemData = await createEntity({
      body,
      auditUid,
      organizationId,
      entitySchemaWithFields,
    });

    const user = await processSignIn({ organizationId, userId: dbItemData.id });

    // aparte de recibir los datos del worker, recibe el addres principal del usuario asociado

    if (body.address) {
      // IAddress
      const userAddressesEntitySchemaWithFields = await fetchSchemaWithFields(
        res,
        organizationId,
        CMSCollections.USERS_ADDRESSES,
        null
      );

      const newUserAddress = { isPrimary: true, address: body.address, userId: dbItemData.id };

      await createEntity({
        body: newUserAddress,
        auditUid,
        organizationId,
        entitySchemaWithFields: userAddressesEntitySchemaWithFields,
      });
    }

    if (body.registerUrlLink) {
      try {
        console.log('entered with registerUrlLink: ' + body.registerUrlLink);
        // parseo la info
        const parsedUrl = new URL('https://example.com' + body.registerUrlLink);

        // remove leading '?' chat
        const query = parseQuery(parsedUrl.search.substr(1));

        const campaignCode = query.campaign;

        if (campaignCode) {
          console.log('campaignCode in QS: ' + campaignCode);
          const campaign = await getCampaignByCode(organizationId, campaignCode);

          if (campaign) {
            console.log('Founed campaign: ' + campaign.id);
            const openPosition = await fetchOpenPositionByCampaignId(organizationId, campaign.id);

            if (openPosition) {
              console.log('Founded openPosition: ' + openPosition.id);
              await createWorkerOpenPositionRelationship(
                organizationId,
                openPosition.id,
                dbItemData.id
              );
              console.log('OK creating worker open position relationship');
            }
          }
        }
      } catch (e) {
        handleCronError({ message: 'Error creating worker open position', error: e });
      }
    }

    return res.status(201).send(user);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.signUpFederatedAuth = async function (req, res) {
  try {
    const { userId: auditUid, email } = res.locals;

    const firebaseUser = await getFirebaseUserById(auditUid);

    let firstName = '';
    let lastName = '';

    try {
      if (firebaseUser.displayName) {
        firstName = firebaseUser.displayName.split(' ')[0];
        lastName = firebaseUser.displayName.split(' ')[1];
      }
    } catch (e) {
      console.error('Error parseando displayName: ', e.message, firebaseUser.displayName);
      // dejo seguir
    }

    const userInputData = {
      firstName,
      lastName,
      email,
      identificationNumber: 'n/a', // tiene que tener un valor, si quisieramos algo distinto deberíamos poner un form en el medio
      appUserStatus: Types.UserStatusTypes.USER_STATUS_TYPE_ACTIVE,
      avatarUrl: firebaseUser.photoURL,
      appRols: [],
    };

    // const itemData = await sanitizeData({ data: userInputData, validationSchema: schemas.create });

    // valido que aún no exista en firestore, si tiene que existir en auth
    const firestoreUser = await getFirestoreUserByEmail(userInputData.email);

    console.log('Usuario consultado: ' + userInputData.email, firestoreUser);

    if (firestoreUser) {
      throw new CustomError.TechnicalError(
        'ERROR_DUPLICATED_EMAIL',
        null,
        'Ya existía el usuario con email ' + userInputData.email,
        null
      );
    }

    console.log('previo a crear usuario unicamente en firestore');

    // const userData = await createUser({
    //   id: auditUid, // si le mando el id entonces no intenta crear el user en el motor de autenticación
    //   auditUid,
    //   userData: itemData,
    //   appUserStatus: itemData.appUserStatus,
    //   password: req.body.password,
    // });

    const organizationId = DEFAULT_ORGANIZATION_ID;
    const schemaName = CMSCollections.WORKERS;

    const entitySchemaWithFields = await fetchSchemaWithFields(
      res,
      organizationId,
      schemaName,
      null
    );

    const dbItemData = await createEntity({
      userInputData,
      auditUid,
      organizationId,
      entitySchemaWithFields,
    });

    const user = await processSignIn({ organizationId, userId: dbItemData.id });

    console.log('Usuario creado OK');

    return res.status(201).send(user);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.listGrantedCompanies = async function (req, res) {
  try {
    const { userId, organizationId } = res.locals;

    console.log('init listGrantedCompanies');

    const userEnterpriseRols = await UserRolesHelper.fetchUserEnterpriseRols({
      organizationId,
      userId,
    });

    let items = [];

    if (userEnterpriseRols.length !== 0) {
      const companiesSchema = buildCompanySchemaWithFields(organizationId);
      items = await fetchItemsByIds({
        collectionName: companiesSchema.collectionName,
        ids: userEnterpriseRols.map((item) => {
          return item.companyId;
        }),
      });

      console.log('OK - findGranted - fetch: ' + items.length);
    }

    let { limit, offset, filters } = req.query;

    if (limit) limit = parseInt(limit);

    const filteredItems = filterItems({ items, limit, offset, filters });

    if (filteredItems.items) {
      console.log('OK - findGranted: ' + filteredItems.items.length);
    } else {
      console.log('OK - findGranted: ' + '0');
    }

    return res.send(filteredItems);
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};

exports.setUserPassword = async function (req, res) {
  try {
    const { uId, password } = req.body;

    await admin.auth().updateUser(uId, {
      password,
    });

    return res.status(200).send();
  } catch (err) {
    return ErrorHelper.handleError(req, res, err);
  }
};
